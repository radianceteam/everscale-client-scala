package client {
  case class ClientError(code: Long, message: String, data: com.radiance.Value)
  case class ClientConfig(network: Option[client.NetworkConfig], crypto: Option[client.CryptoConfig], abi: Option[client.AbiConfig])
  case class NetworkConfig(server_address: String, network_retries_count: Option[Int], message_retries_count: Option[Int], message_processing_timeout: Option[Long], wait_for_timeout: Option[Long], out_of_sync_threshold: Option[Long], access_key: Option[String])
  case class CryptoConfig(mnemonic_dictionary: Option[Long], mnemonic_word_count: Option[Long], hdkey_derivation_path: Option[St




  case class CryptoConfig(mnemonic_dictionary: Option[Long], mnemonic_word_count: Option[Long], hdkey_derivation_path: Option[String])
  case class AbiConfig(workchain: Option[Int], message_expiration_timeout: Option[Long], message_expiration_timeout_grow_factor: Option[Float])
  case class BuildInfoDependency(name: String, git_commit: String)
  case class ParamsOfAppRequest(app_request_id: Long, request_data: com.radiance.Value)
  sealed trait AppRequestResult
  case class Error(text: String) extends AppRequestResult
  case class Ok(result: com.radiance.Value) extends AppRequestResult
  case class ResultOfGetApiReference(api: com.radiance.API)
  case class ResultOfVersion(version: String)
  case class ResultOfBuildInfo(build_number: Long, dependencies: List[client.BuildInfoDependency])
  case class ParamsOfResolveAppRequest(app_request_id: Long, result: client.AppRequestResult)
}
/**
 * @param app_request_id
 * @param result
 */




def resolve_app_request(app_request_id: Long, result: client.AppRequestResult): Unit
/**
 */
def build_info(): client.ResultOfBuildInfo
/**
 */
def version(): client.ResultOfVersion
/**
 */
def get_api_reference(): client.ResultOfGetApiReference
package crypto {
  case class SigningBoxHandle(value: BigInt)
  case class ParamsOfFactorize(composite: String)
  case class ResultOfFactorize(factors: List[String])
  case class ParamsOfModularPower(base: String, exponent: String, modulus: String)
  case class ResultOfModularPower(modular_power: String)
  case class ParamsOfTonCrc16(data: String)
  case class ResultOfTonCrc16(crc: Long)
  case class ParamsOfGenerateRandomBytes(length: Long)
  case class ResultOfGenerateRandomBytes(bytes: String)
  case class ParamsOfConvertPublicKeyToTonSafeFormat(public_key: String)
  case class ResultOfConvertPublicKeyToTonSafeFormat(ton_public_key: String)
  case class KeyPair(public: String, secret: String)
  case class ParamsOfSign(unsigned: String, keys: crypto.KeyPair)
  case class ResultOfSign(signed: String, signature: String)
  case class ParamsOfVerifySignature(signed: String, public: String)
  case class ResultOfVerifySignature(unsigned: String)
  case class ParamsOfHash(data: String)
  case class ResultOfHash(hash: String)
  case class ParamsOfScrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long)
  case class ResultOfScrypt(key: String)
  case class ParamsOfNaclSignKeyPairFromSecret(secret: String)
  case class ParamsOfNaclSign(unsigned: String, secret: String)
  case class ResultOfNaclSign(signed: String)
  case class ParamsOfNaclSignOpen(signed: String, public: String)
  case class ResultOfNaclSignOpen(unsigned: String)
  case class ResultOfNaclSignDetached(signature: String)
  case class ParamsOfNaclBoxKeyPairFromSecret(secret: String)
  case class ParamsOfNaclBox(decrypted: String, nonce: String, their_public: String, secret: String)
  case class ResultOfNaclBox(encrypted: String)
  case class ParamsOfNaclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String)
  case class ResultOfNaclBoxOpen(decrypted: String)
  case class ParamsOfNaclSecretBox(decrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSecretBoxOpen(encrypted: String, nonce: String, key: String)
  case class ParamsOfMnemonicWords(dictionary: Option[Long])
  case class ResultOfMnemonicWords(words: String)
  case class ParamsOfMnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicFromRandom(phrase: String)
  case class ParamsOfMnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicFromEntropy(phrase: String)
  case class ParamsOfMnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicVerify(valid: Boolean)
  case class ParamsOfMnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfHDKeyXPrvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfHDKeyXPrvFromMnemonic(xprv: String)
  case class ParamsOfHDKeyDeriveFromXPrv(xprv: String, child_index: Long, hardened: Boolean)
  case class ResultOfHDKeyDeriveFromXPrv(xprv: String)
  case class ParamsOfHDKeyDeriveFromXPrvPath(xprv: String, path: String)
  case class ResultOfHDKeyDeriveFromXPrvPath(xprv: String)
  case class ParamsOfHDKeySecretFromXPrv(xprv: String)
  case class ResultOfHDKeySecretFromXPrv(secret: String)
  case class ParamsOfHDKeyPublicFromXPrv(xprv: String)
  case class ResultOfHDKeyPublicFromXPrv(public: String)
  case class ParamsOfChaCha20(data: String, key: String, nonce: String)
  case class ResultOfChaCha20(data: String)
  case class RegisteredSigningBox(handle: crypto.SigningBoxHandle)
  sealed trait ParamsOfAppSigningBox
  case class GetPublicKey() extends ParamsOfAppSigningBox
  case class Sign(unsigned: String) extends ParamsOfAppSigningBox
  sealed trait ResultOfAppSigningBox
  case class GetPublicKey(public_key: String) extends ResultOfAppSigningBox
  case class Sign(signature: String) extends ResultOfAppSigningBox
  case class ResultOfSigningBoxGetPublicKey(pubkey: String)
  case class ParamsOfSigningBoxSign(signing_box: crypto.SigningBoxHandle, unsigned: String)
  case class ResultOfSigningBoxSign(signature: String)
}
/** @param handle  */
def remove_signing_box(handle: crypto.SigningBoxHandle): Unit
/**
 * @param signing_box
 * @param unsigned Must be encoded with `base64`.
 */
def signing_box_sign(signing_box: crypto.SigningBoxHandle, unsigned: String): crypto.ResultOfSigningBoxSign
/** @param handle  */
def signing_box_get_public_key(handle: crypto.SigningBoxHandle): crypto.ResultOfSigningBoxGetPublicKey
/**
 * @param public
 * @param secret
 */
def get_signing_box(public: String, secret: String): crypto.RegisteredSigningBox
ATTENTION:
AppObject
/** @param app_object  */
def register_signing_box(app_object: crypto.ParamsOfAppSigningBox): crypto.RegisteredSigningBox
/**
 * @param data Must be encoded with `base64`.
 * @param key Must be encoded with `hex`.
 * @param nonce Must be encoded with `hex`.
 */
def chacha20(data: String, key: String, nonce: String): crypto.ResultOfChaCha20
/** @param xprv  */
def hdkey_public_from_xprv(xprv: String): crypto.ResultOfHDKeyPublicFromXPrv
/** @param xprv  */
def hdkey_secret_from_xprv(xprv: String): crypto.ResultOfHDKeySecretFromXPrv
/**
 * @param xprv
 * @param path
 */
def hdkey_derive_from_xprv_path(xprv: String, path: String): crypto.ResultOfHDKeyDeriveFromXPrvPath
/**
 * @param xprv
 * @param child_index
 * @param hardened
 */
def hdkey_derive_from_xprv(xprv: String, child_index: Long, hardened: Boolean): crypto.ResultOfHDKeyDeriveFromXPrv
/**
 * @param phrase
 * @param dictionary
 * @param word_count
 */
def hdkey_xprv_from_mnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfHDKeyXPrvFromMnemonic
/**
 * @param phrase
 * @param path
 * @param dictionary
 * @param word_count
 */
def mnemonic_derive_sign_keys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long]): crypto.KeyPair
/**
 * @param phrase
 * @param dictionary
 * @param word_count
 */
def mnemonic_verify(phrase: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicVerify
/**
 * @param entropy Hex encoded.
 * @param dictionary
 * @param word_count
 */
def mnemonic_from_entropy(entropy: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicFromEntropy
/**
 * @param dictionary
 * @param word_count
 */
def mnemonic_from_random(dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicFromRandom
/** @param dictionary  */
def mnemonic_words(dictionary: Option[Long]): crypto.ResultOfMnemonicWords
/**
 * @param encrypted Encoded with `base64`.
 * @param nonce
 * @param key
 */
def nacl_secret_box_open(encrypted: String, nonce: String, key: String): crypto.ResultOfNaclBoxOpen
/**
 * @param decrypted Encoded with `base64`.
 * @param nonce
 * @param key
 */
def nacl_secret_box(decrypted: String, nonce: String, key: String): crypto.ResultOfNaclBox
/**
 * @param encrypted Encoded with `base64`.
 * @param nonce
 * @param their_public
 * @param secret
 */
def nacl_box_open(encrypted: String, nonce: String, their_public: String, secret: String): crypto.ResultOfNaclBoxOpen
/**
 * Public key authenticated encryption
 * Encrypt and authenticate a message using the senders secret key, the recievers public
 * key, and a nonce.@param decrypted
 * @param nonce
 * @param their_public
 * @param secret
 */
def nacl_box(decrypted: String, nonce: String, their_public: String, secret: String): crypto.ResultOfNaclBox
/** @param secret  */
def nacl_box_keypair_from_secret_key(secret: String): crypto.KeyPair
/**
 */
def nacl_box_keypair(): crypto.KeyPair
/**
 * @param unsigned
 * @param secret
 */
def nacl_sign_detached(unsigned: String, secret: String): crypto.ResultOfNaclSignDetached
/**
 * @param signed Encoded with `base64`.
 * @param public
 */
def nacl_sign_open(signed: String, public: String): crypto.ResultOfNaclSignOpen
/**
 * @param unsigned
 * @param secret
 */
def nacl_sign(unsigned: String, secret: String): crypto.ResultOfNaclSign
/** @param secret  */
def nacl_sign_keypair_from_secret_key(secret: String): crypto.KeyPair
/**
 * Derives key from `password` and `key` using `scrypt` algorithm. See [https://en.wikipedia.org/wiki/Scrypt].
 * # Arguments
 * - `log_n` - The log2 of the Scrypt parameter `N`
 * - `r` - The Scrypt parameter `r`
 * - `p` - The Scrypt parameter `p`
 * # Conditions
 * - `log_n` must be less than `64`
 * - `r` must be greater than `0` and less than or equal to `4294967295`
 * - `p` must be greater than `0` and less than `4294967295`
 * # Recommended values sufficient for most use-cases
 * - `log_n = 15` (`n = 32768`)
 * - `r = 8`
 * - `p = 1`@param password
 * @param salt
 * @param log_n
 * @param r
 * @param p
 * @param dk_len
 */
def scrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long): crypto.ResultOfScrypt
/** @param data Encoded with `base64`. */
def sha512(data: String): crypto.ResultOfHash
/** @param data Encoded with `base64`. */
def sha256(data: String): crypto.ResultOfHash
/**
 * @param signed
 * @param public
 */
def verify_signature(signed: String, public: String): crypto.ResultOfVerifySignature
/**
 * @param unsigned
 * @param keys
 */
def sign(unsigned: String, keys: crypto.KeyPair): crypto.ResultOfSign
/**
 */
def generate_random_sign_keys(): crypto.KeyPair
/** @param public_key  */
def convert_public_key_to_ton_safe_format(public_key: String): crypto.ResultOfConvertPublicKeyToTonSafeFormat
/** @param length  */
def generate_random_bytes(length: Long): crypto.ResultOfGenerateRandomBytes
/** @param data Encoded with `base64`. */
def ton_crc16(data: String): crypto.ResultOfTonCrc16
/**
 * @param base
 * @param exponent
 * @param modulus
 */
def modular_power(base: String, exponent: String, modulus: String): crypto.ResultOfModularPower
/** @param composite  */
def factorize(composite: String): crypto.ResultOfFactorize
package abi {
  sealed trait Abi
  case class Contract(value: abi.AbiContract) extends Abi
  case class Json(value: String) extends Abi
  case class Handle(value: abi.AbiHandle) extends Abi
  case class Serialized(value: abi.AbiContract) extends Abi
  case class AbiHandle(value: BigInt)
  /**
   * The ABI function header.
   * Includes several hidden function parameters that contract
   * uses for security, message delivery monitoring and replay protection reasons.
   *
   * The actual set of header fields depends on the contract's ABI.
   * If a contract's ABI does not include some headers, then they are not filled.
   */
  case class FunctionHeader(expire: Option[Long], time: Option[BigInt], pubkey: Option[String])
  case class CallSet(function_name: String, header: Option[abi.FunctionHeader], input: Option[com.radiance.Value])
  case class DeploySet(tvc: String, workchain_id: Option[Int], initial_data: Option[com.radiance.Value])
  sealed trait Signer
  case class None() extends Signer
  case class External(public_key: String) extends Signer
  case class Keys(keys: crypto.KeyPair) extends Signer
  case class SigningBox(handle: crypto.SigningBoxHandle) extends Signer
  sealed trait MessageBodyType
  object Input extends MessageBodyType
  object Output extends MessageBodyType
  /**
   * Message contains the input of the imported ABI function.
   * Occurs when contract sends an internal message to other
   * contract.
   */
  object InternalOutput extends MessageBodyType
  object Event extends MessageBodyType
  sealed trait StateInitSource
  case class Message(source: abi.MessageSource) extends StateInitSource
  case class StateInit(code: String, data: String, library: Option[String]) extends StateInitSource
  case class Tvc(tvc: String, public_key: Option[String], init_params: Option[abi.StateInitParams]) extends StateInitSource
  case class StateInitParams(abi: abi.Abi, value: com.radiance.Value)
  sealed trait MessageSource
  case class Encoded(message: String, abi: Option[abi.Abi]) extends MessageSource
  case class EncodingParams(value: abi.ParamsOfEncodeMessage) extends MessageSource
  case class AbiParam(name: String, `type`: String, components: Option[List[abi.AbiParam]])
  case class AbiEvent(name: String, inputs: List[abi.AbiParam], id: Option[Option[String]])
  case class AbiData(key: BigInt, name: String, `type`: String, components: Option[List[abi.AbiParam]])
  case class AbiFunction(name: String, inputs: List[abi.AbiParam], outputs: List[abi.AbiParam], id: Option[Option[String]])
  case class AbiContract(`ABI version`: Option[Long], abi_version: Option[Long], header: Option[List[String]], functions: Option[List[abi.AbiFunction]], events: Option[List[abi.AbiEvent]], data: Option[List[abi.AbiData]])
  case class ParamsOfEncodeMessageBody(abi: abi.Abi, call_set: abi.CallSet, is_internal: Boolean, signer: abi.Signer, processing_try_index: Option[Long])
  case class ResultOfEncodeMessageBody(body: String, data_to_sign: Option[String])
  case class ParamsOfAttachSignatureToMessageBody(abi: abi.Abi, public_key: String, message: String, signature: String)
  case class ResultOfAttachSignatureToMessageBody(body: String)
  case class ParamsOfEncodeMessage(abi: abi.Abi, address: Option[String], deploy_set: Option[abi.DeploySet], call_set: Option[abi.CallSet], signer: abi.Signer, processing_try_index: Option[Long])
  case class ResultOfEncodeMessage(message: String, data_to_sign: Option[String], address: String, message_id: String)
  case class ParamsOfAttachSignature(abi: abi.Abi, public_key: String, message: String, signature: String)
  case class ResultOfAttachSignature(message: String, message_id: String)
  case class ParamsOfDecodeMessage(abi: abi.Abi, message: String)
  case class DecodedMessageBody(body_type: abi.MessageBodyType, name: String, value: Option[com.radiance.Value], header: Option[abi.FunctionHeader])
  case class ParamsOfDecodeMessageBody(abi: abi.Abi, body: String, is_internal: Boolean)
  case class ParamsOfEncodeAccount(state_init: abi.StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long])
  case class ResultOfEncodeAccount(account: String, id: String)
}
/**
 * Creates account state BOC
 * Creates account state provided with one of these sets of data :
 * 1. BOC of code, BOC of data, BOC of library
 * 2. TVC (string in `base64`), keys, init params@param state_init
 * @param balance
 * @param last_trans_lt
 * @param last_paid
 */
def encode_account(state_init: abi.StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long]): abi.ResultOfEncodeAccount
/**
 * @param abi
 * @param body
 * @param is_internal
 */
def decode_message_body(abi: abi.Abi, body: String, is_internal: Boolean): abi.DecodedMessageBody
/**
 * @param abi
 * @param message
 */
def decode_message(abi: abi.Abi, message: String): abi.DecodedMessageBody
/**
 * @param abi
 * @param public_key
 * @param message
 * @param signature
 */
def attach_signature(abi: abi.Abi, public_key: String, message: String, signature: String): abi.ResultOfAttachSignature
/**
 * Encodes an ABI-compatible message
 * Allows to encode deploy and function call messages,
 * both signed and unsigned.
 *
 * Use cases include messages of any possible type:
 * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
 * of initialization);
 * - deploy without initial function call;
 * - signed/unsigned + data for signing.
 *
 * `Signer` defines how the message should or shouldn't be signed:
 *
 * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,
 * that do not require authorization by pubkey.
 *
 * `Signer::External` takes public key and returns `data_to_sign` for later signing.
 * Use `attach_signature` method with the result signature to get the signed message.
 *
 * `Signer::Keys` creates a signed message with provided key pair.
 *
 * [SOON] `Signer::SigningBox` Allows using a special interface to imlepement signing
 * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,
 * when application calls some API to sign data.@param abi
 * @param address Must be specified in case of non-deploy message.
 * @param deploy_set Must be specified in case of deploy message.
 * @param call_set Must be specified in case of non-deploy message.
 *
 * In case of deploy message it is optional and contains parameters
 * of the functions that will to be called upon deploy transaction.
 * @param signer
 * @param processing_try_index Used in message processing with retries (if contract's ABI includes "expire" header).
 *
 * Encoder uses the provided try index to calculate message
 * expiration time. The 1st message expiration time is specified in
 * Client config.
 *
 * Expiration timeouts will grow with every retry.
 * Retry grow factor is set in Client config:
 * <.....add config parameter with default value here>
 *
 * Default value is 0.
 */
def encode_message(abi: abi.Abi, address: Option[String], deploy_set: Option[abi.DeploySet], call_set: Option[abi.CallSet], signer: abi.Signer, processing_try_index: Option[Long]): abi.ResultOfEncodeMessage
/**
 * @param abi
 * @param public_key Must be encoded with `hex`.
 * @param message Must be encoded with `base64`.
 * @param signature Must be encoded with `hex`.
 */
def attach_signature_to_message_body(abi: abi.Abi, public_key: String, message: String, signature: String): abi.ResultOfAttachSignatureToMessageBody
/**
 * @param abi
 * @param call_set Must be specified in non deploy message.
 *
 * In case of deploy message contains parameters of constructor.
 * @param is_internal
 * @param signer
 * @param processing_try_index Used in message processing with retries.
 *
 * Encoder uses the provided try index to calculate message
 * expiration time.
 *
 * Expiration timeouts will grow with every retry.
 *
 * Default value is 0.
 */
def encode_message_body(abi: abi.Abi, call_set: abi.CallSet, is_internal: Boolean, signer: abi.Signer, processing_try_index: Option[Long]): abi.ResultOfEncodeMessageBody
package boc {
  case class ParamsOfParse(boc: String)
  case class ResultOfParse(parsed: com.radiance.Value)
  case class ParamsOfParseShardstate(boc: String, id: String, workchain_id: Int)
  case class ParamsOfGetBlockchainConfig(block_boc: String)
  case class ResultOfGetBlockchainConfig(config_boc: String)
  case class ParamsOfGetBocHash(boc: String)
  case class ResultOfGetBocHash(hash: String)
}
/** @param boc  */
def get_boc_hash(boc: String): boc.ResultOfGetBocHash
/** @param block_boc  */
def get_blockchain_config(block_boc: String): boc.ResultOfGetBlockchainConfig
/**
 * Parses shardstate boc into a JSON
 * JSON structure is compatible with GraphQL API shardstate object@param boc
 * @param id
 * @param workchain_id
 */
def parse_shardstate(boc: String, id: String, workchain_id: Int): boc.ResultOfParse
/**
 * Parses block boc into a JSON
 * JSON structure is compatible with GraphQL API block object@param boc
 */
def parse_block(boc: String): boc.ResultOfParse
/**
 * Parses account boc into a JSON
 * JSON structure is compatible with GraphQL API account object@param boc
 */
def parse_account(boc: String): boc.ResultOfParse
/**
 * Parses transaction boc into a JSON
 * JSON structure is compatible with GraphQL API transaction object@param boc
 */
def parse_transaction(boc: String): boc.ResultOfParse
/**
 * Parses message boc into a JSON
 * JSON structure is compatible with GraphQL API message object@param boc
 */
def parse_message(boc: String): boc.ResultOfParse
package processing {
  sealed trait ProcessingEvent
  case class WillFetchFirstBlock() extends ProcessingEvent
  case class FetchFirstBlockFailed(error: client.ClientError) extends ProcessingEvent
  case class WillSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class DidSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class SendFailed(shard_block_id: String, message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class WillFetchNextBlock(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class FetchNextBlockFailed(shard_block_id: String, message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class MessageExpired(message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class ResultOfProcessMessage(transaction: com.radiance.Value, out_messages: List[String], decoded: Option[processing.DecodedOutput], fees: tvm.TransactionFees)
  case class DecodedOutput(out_messages: List[Option[abi.DecodedMessageBody]], output: Option[com.radiance.Value])
  case class ParamsOfSendMessage(message: String, abi: Option[abi.Abi], send_events: Boolean)
  case class ResultOfSendMessage(shard_block_id: String)
  case class ParamsOfWaitForTransaction(abi: Option[abi.Abi], message: String, shard_block_id: String, send_events: Boolean)
  case class ParamsOfProcessMessage(message_encode_params: abi.ParamsOfEncodeMessage, send_events: Boolean)
}
/**
 * Creates message, sends it to the network and monitors its processing.
 * Creates ABI-compatible message,
 * sends it to the network and monitors for the result transaction.
 * Decodes the output messages' bodies.
 *
 * If contract's ABI includes "expire" header, then
 * SDK implements retries in case of unsuccessful message delivery within the expiration
 * timeout: SDK recreates the message, sends it and processes it again.
 *
 * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,
 * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag
 * and logged into the supplied callback function.
 * The retry configuration parameters are defined in config:
 * <add correct config params here>
 * pub const DEFAULT_EXPIRATION_RETRIES_LIMIT: i8 = 3; - max number of retries
 * pub const DEFAULT_EXPIRATION_TIMEOUT: u32 = 40000;  - message expiration timeout in ms.
 * pub const DEFAULT_....expiration_timeout_grow_factor... = 1.5 - factor that increases the expiration timeout for each retry
 *
 * If contract's ABI does not include "expire" header
 * then, if no transaction is found within the network timeout (see config parameter ), exits with error.@param message_encode_params
 * @param send_events
 * @param request
 */
def process_message(message_encode_params: abi.ParamsOfEncodeMessage, send_events: Boolean, request: Request): processing.ResultOfProcessMessage
/**
 * Performs monitoring of the network for the result transaction of the external inbound message processing.
 * `send_events` enables intermediate events, such as `WillFetchNextBlock`,
 * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation
 * during message processing.
 *
 * Note, that presence of the `abi` parameter is critical for ABI
 * compliant contracts. Message processing uses drastically
 * different strategy for processing message for contracts which
 * ABI includes "expire" header.
 *
 * When the ABI header `expire` is present, the processing uses
 * `message expiration` strategy:
 * - The maximum block gen time is set to
 *   `message_expiration_timeout + transaction_wait_timeout`.
 * - When maximum block gen time is reached, the processing will
 *   be finished with `MessageExpired` error.
 *
 * When the ABI header `expire` isn't present or `abi` parameter
 * isn't specified, the processing uses `transaction waiting`
 * strategy:
 * - The maximum block gen time is set to
 *   `now() + transaction_wait_timeout`.
 *
 * - If maximum block gen time is reached and no result transaction is found,
 * the processing will exit with an error.@param abi If it is specified, then the output messages' bodies will be
 * decoded according to this ABI.
 *
 * The `abi_decoded` result field will be filled out.
 * @param message Encoded with `base64`.
 * @param shard_block_id You must provide the same value as the `send_message` has returned.
 * @param send_events
 * @param callback
 */
def wait_for_transaction(abi: Option[abi.Abi], message: String, shard_block_id: String, send_events: Boolean, callback: Request): processing.ResultOfProcessMessage
/**
 * Sends message to the network and returns the last generated shard block of the destination account
 * before the message was sent. It will be required later for message processing.@param message
 * @param abi If this parameter is specified and the message has the
 * `expire` header then expiration time will be checked against
 * the current time to prevent unnecessary sending of already expired message.
 *
 * The `message already expired` error will be returned in this
 * case.
 *
 * Note, that specifying `abi` for ABI compliant contracts is
 * strongly recommended, so that proper processing strategy can be
 * chosen.
 * @param send_events
 * @param callback
 */
def send_message(message: String, abi: Option[abi.Abi], send_events: Boolean, callback: Request): processing.ResultOfSendMessage
package utils {
  sealed trait AddressStringFormat
  case class AccountId() extends AddressStringFormat
  case class Hex() extends AddressStringFormat
  case class Base64(url: Boolean, test: Boolean, bounce: Boolean) extends AddressStringFormat
  case class ParamsOfConvertAddress(address: String, output_format: utils.AddressStringFormat)
  case class ResultOfConvertAddress(address: String)
}
/**
 * @param address
 * @param output_format
 */
def convert_address(address: String, output_format: utils.AddressStringFormat): utils.ResultOfConvertAddress
package tvm {
  case class ExecutionOptions(blockchain_config: Option[String], block_time: Option[Long], block_lt: Option[BigInt], transaction_lt: Option[BigInt])
  sealed trait AccountForExecutor
  case class None() extends AccountForExecutor
  case class Uninit() extends AccountForExecutor
  case class Account(boc: String, unlimited_balance: Option[Boolean]) extends AccountForExecutor
  case class TransactionFees(in_msg_fwd_fee: BigInt, storage_fee: BigInt, gas_fee: BigInt, out_msgs_fwd_fee: BigInt, total_account_fees: BigInt, total_output: BigInt)
  case class ParamsOfRunExecutor(message: String, account: tvm.AccountForExecutor, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi], skip_transaction_check: Option[Boolean])
  case class ResultOfRunExecutor(transaction: com.radiance.Value, out_messages: List[String], decoded: Option[processing.DecodedOutput], account: String, fees: tvm.TransactionFees)
  case class ParamsOfRunTvm(message: String, account: String, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi])
  case class ResultOfRunTvm(out_messages: List[String], decoded: Option[processing.DecodedOutput], account: String)
  case class ParamsOfRunGet(account: String, function_name: String, input: Option[com.radiance.Value], execution_options: Option[tvm.ExecutionOptions])
  case class ResultOfRunGet(output: com.radiance.Value)
}
/**
 * @param account
 * @param function_name
 * @param input
 * @param execution_options
 */
def run_get(account: String, function_name: String, input: Option[com.radiance.Value], execution_options: Option[tvm.ExecutionOptions]): tvm.ResultOfRunGet
/**
 * @param message Must be encoded as base64.
 * @param account Must be encoded as base64.
 * @param execution_options
 * @param abi
 */
def run_tvm(message: String, account: String, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi]): tvm.ResultOfRunTvm
/**
 * @param message Must be encoded as base64.
 * @param account
 * @param execution_options
 * @param abi
 * @param skip_transaction_check
 */
def run_executor(message: String, account: tvm.AccountForExecutor, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi], skip_transaction_check: Option[Boolean]): tvm.ResultOfRunExecutor
package net {
  case class OrderBy(path: String, direction: net.SortDirection)
  sealed trait SortDirection
  object ASC extends SortDirection
  object DESC extends SortDirection
  case class ParamsOfQuery(query: String, variables: Option[com.radiance.Value])
  case class ResultOfQuery(result: com.radiance.Value)
  case class ParamsOfQueryCollection(collection: String, filter: Option[com.radiance.Value], result: String, order: Option[List[net.OrderBy]], limit: Option[Long])
  case class ResultOfQueryCollection(result: List[com.radiance.Value])
  case class ParamsOfWaitForCollection(collection: String, filter: Option[com.radiance.Value], result: String, timeout: Option[Long])
  case class ResultOfWaitForCollection(result: com.radiance.Value)
  case class ResultOfSubscribeCollection(handle: Long)
  case class ParamsOfSubscribeCollection(collection: String, filter: Option[com.radiance.Value], result: String)
}
/**  Resumes network module to enable network activity */
def resume(): Unit
/**  Suspends network module to stop any network activity */
def suspend(): Unit
/**
 * Creates a subscription
 * Triggers for each insert/update of data
 * that satisfies the `filter` conditions.
 * The projection fields are limited to `result` fields.@param collection
 * @param filter
 * @param result
 * @param callback
 */
def subscribe_collection(collection: String, filter: Option[com.radiance.Value], result: String, callback: Request): net.ResultOfSubscribeCollection
/** Cancels a subscription specified by its handle.@param handle Must be closed with `unsubscribe` */
def unsubscribe(handle: Long): Unit
/**
 * Returns an object that fulfills the conditions or waits for its appearance
 * Triggers only once.
 * If object that satisfies the `filter` conditions
 * already exists - returns it immediately.
 * If not - waits for insert/update of data within the specified `timeout`,
 * and returns it.
 * The projection fields are limited to `result` fields@param collection
 * @param filter
 * @param result
 * @param timeout
 */
def wait_for_collection(collection: String, filter: Option[com.radiance.Value], result: String, timeout: Option[Long]): net.ResultOfWaitForCollection
/**
 * Queries collection data
 * Queries data that satisfies the `filter` conditions,
 * limits the number of returned records and orders them.
 * The projection fields are limited to `result` fields@param collection
 * @param filter
 * @param result
 * @param order
 * @param limit
 */
def query_collection(collection: String, filter: Option[com.radiance.Value], result: String, order: Option[List[net.OrderBy]], limit: Option[Long]): net.ResultOfQueryCollection
/**
 * @param query
 * @param variables Must be a map with named values thatcan be used in query.
 */
def query(query: String, variables: Option[com.radiance.Value]): net.ResultOfQuery
package debot {
  case class DebotHandle(value: BigInt)
  case class DebotAction(description: String, name: String, action_type: Long, to: Long, attributes: String, misc: String)
  case class ParamsOfStart(address: String)
  case class RegisteredDebot(debot_handle: debot.DebotHandle)
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  sealed trait ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class Log(msg: String) extends ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class Switch(context_id: Long) extends ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class ShowAction(action: debot.DebotAction) extends ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class Input(prompt: String) extends ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class GetSigningBox() extends ParamsOfAppDebotBrowser
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  case class InvokeDebot(debot_addr: String, action: debot.DebotAction) extends ParamsOfAppDebotBrowser
  sealed trait ResultOfAppDebotBrowser
  case class Input(value: String) extends ResultOfAppDebotBrowser
  case class GetSigningBox(signing_box: crypto.SigningBoxHandle) extends ResultOfAppDebotBrowser
  case class InvokeDebot() extends ResultOfAppDebotBrowser
  case class ParamsOfFetch(address: String)
  case class ParamsOfExecute(debot_handle: debot.DebotHandle, action: debot.DebotAction)
}
/**
 * [UNSTABLE](UNSTABLE.md) Destroys debot handle.
 * Removes handle from Client Context and drops debot engine referenced by that handle.@param debot_handle
 */
def remove(debot_handle: debot.DebotHandle): Unit
/**
 * [UNSTABLE](UNSTABLE.md) Executes debot action.
 * Calls debot engine referenced by debot handle to execute input action.
 * Calls Debot Browser Callbacks if needed.
 *
 * # Remarks
 * Chain of actions can be executed if input action generates a list of subactions.@param debot_handle
 * @param action
 */
def execute(debot_handle: debot.DebotHandle, action: debot.DebotAction): Unit
ATTENTION:
AppObject
/**
 * [UNSTABLE](UNSTABLE.md) Fetches debot from blockchain.
 * Downloads debot smart contract (code and data) from blockchain and creates
 * an instance of Debot Engine for it.
 *
 * # Remarks
 * It does not switch debot to context 0. Browser Callbacks are not called.@param address
 * @param app_object
 */
def fetch(address: String, app_object: debot.ParamsOfAppDebotBrowser): debot.RegisteredDebot
ATTENTION:
AppObject
/**
 * [UNSTABLE](UNSTABLE.md) Starts an instance of debot.
 * Downloads debot smart contract from blockchain and switches it to
 * context zero.
 * Returns a debot handle which can be used later in `execute` function.
 * This function must be used by Debot Browser to start a dialog with debot.
 * While the function is executing, several Browser Callbacks can be called,
 * since the debot tries to display all actions from the context 0 to the user.
 *
 * # Remarks
 * `start` is equivalent to `fetch` + switch to context 0.@param address
 * @param app_object
 */
def start(address: String, app_object: debot.ParamsOfAppDebotBrowser): debot.RegisteredDebot