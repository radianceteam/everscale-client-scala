package client {
  case class AbiConfig(workchain: Option[Int], message_expiration_timeout: Option[Long], message_expiration_timeout_grow_factor: Option[Float])
  sealed trait AppRequestResult
  object AppRequestResult {
    case class Error(text: String) extends AppRequestResult
    case class Ok(result: Value) extends AppRequestResult
  }
  case class BuildInfoDependency(name: String, git_commit: String)
  case class ClientConfig(network: Option[NetworkConfig], crypto: Option[CryptoConfig], abi: Option[AbiConfig])
  case class ClientError(code: Long, message: String, data: Value)
  sealed trait ClientErrorCode {
    val code: String
  }
  object ClientErrorCode {
    case object AppRequestError extends ClientErrorCode {
      override val code: String = "26"
    }
    case object CallbackNotRegistered extends ClientErrorCode {
      override val code: String = "13"
    }
    case object CallbackParamsCantBeConvertedToJson extends ClientErrorCode {
      override val code: String = "5"
    }
    case object CanNotParseNumber extends ClientErrorCode {
      override val code: String = "32"
    }
    case object CanNotParseRequestResult extends ClientErrorCode {
      override val code: String = "30"
    }
    case object CanNotReceiveRequestResult extends ClientErrorCode {
      override val code: String = "29"
    }
    case object CanNotSendRequestResult extends ClientErrorCode {
      override val code: String = "28"
    }
    case object CannotConvertJsValueToJson extends ClientErrorCode {
      override val code: String = "20"
    }
    case object CannotCreateRuntime extends ClientErrorCode {
      override val code: String = "16"
    }
    case object CannotReceiveSpawnedResult extends ClientErrorCode {
      override val code: String = "21"
    }
    case object CannotSerializeError extends ClientErrorCode {
      override val code: String = "19"
    }
    case object CannotSerializeResult extends ClientErrorCode {
      override val code: String = "18"
    }
    case object ContractsAddressConversionFailed extends ClientErrorCode {
      override val code: String = "24"
    }
    case object HttpClientCreateError extends ClientErrorCode {
      override val code: String = "9"
    }
    case object HttpRequestCreateError extends ClientErrorCode {
      override val code: String = "10"
    }
    case object HttpRequestParseError extends ClientErrorCode {
      override val code: String = "12"
    }
    case object HttpRequestSendError extends ClientErrorCode {
      override val code: String = "11"
    }
    case object InternalError extends ClientErrorCode {
      override val code: String = "33"
    }
    case object InvalidAddress extends ClientErrorCode {
      override val code: String = "4"
    }
    case object InvalidBase64 extends ClientErrorCode {
      override val code: String = "3"
    }
    case object InvalidConfig extends ClientErrorCode {
      override val code: String = "15"
    }
    case object InvalidContextHandle extends ClientErrorCode {
      override val code: String = "17"
    }
    case object InvalidHex extends ClientErrorCode {
      override val code: String = "2"
    }
    case object InvalidParams extends ClientErrorCode {
      override val code: String = "23"
    }
    case object NetModuleNotInit extends ClientErrorCode {
      override val code: String = "14"
    }
    case object NoSuchRequest extends ClientErrorCode {
      override val code: String = "27"
    }
    case object NotImplemented extends ClientErrorCode {
      override val code: String = "1"
    }
    case object SetTimerError extends ClientErrorCode {
      override val code: String = "22"
    }
    case object UnexpectedCallbackResponse extends ClientErrorCode {
      override val code: String = "31"
    }
    case object UnknownFunction extends ClientErrorCode {
      override val code: String = "25"
    }
    case object WebsocketConnectError extends ClientErrorCode {
      override val code: String = "6"
    }
    case object WebsocketReceiveError extends ClientErrorCode {
      override val code: String = "7"
    }
    case object WebsocketSendError extends ClientErrorCode {
      override val code: String = "8"
    }
  }
  /** Crypto config. */
  case class CryptoConfig(mnemonic_dictionary: Option[Long], mnemonic_word_count: Option[Long], hdkey_derivation_path: Option[String])
  case class NetworkConfig(server_address: Option[String], endpoints: Option[List[String]], network_retries_count: Option[Int], message_retries_count: Option[Int], message_processing_timeout: Option[Long], wait_for_timeout: Option[Long], out_of_sync_threshold: Option[Long], reconnect_timeout: Option[Long], access_key: Option[String])
  case class ParamsOfAppRequest(app_request_id: Long, request_data: Value)
  case class ParamsOfResolveAppRequest(app_request_id: Long, result: AppRequestResult)
  case class ResultOfBuildInfo(build_number: Long, dependencies: List[BuildInfoDependency])
  case class ResultOfGetApiReference(api: API)
  case class ResultOfVersion(version: String)
}
package client {
  /** Returns detailed information about this build. */
  def buildInfo(): Future[Either[Throwable, ResultOfBuildInfo]]
  /** Returns Core Library API reference */
  def getApiReference(): Future[Either[Throwable, ResultOfGetApiReference]]
  /**
   * Resolves application request processing result
   * @param app_request_id
   * @param result
   */
  def resolveAppRequest(app_request_id: Long, result: AppRequestResult): Future[Either[Throwable, Unit]]
  /** Returns Core Library version */
  def version(): Future[Either[Throwable, ResultOfVersion]]
}
package crypto {
  sealed trait CryptoErrorCode {
    val code: String
  }
  object CryptoErrorCode {
    case object Bip32InvalidDerivePath extends CryptoErrorCode {
      override val code: String = "116"
    }
    case object Bip32InvalidKey extends CryptoErrorCode {
      override val code: String = "115"
    }
    case object Bip39InvalidDictionary extends CryptoErrorCode {
      override val code: String = "117"
    }
    case object Bip39InvalidEntropy extends CryptoErrorCode {
      override val code: String = "113"
    }
    case object Bip39InvalidPhrase extends CryptoErrorCode {
      override val code: String = "114"
    }
    case object Bip39InvalidWordCount extends CryptoErrorCode {
      override val code: String = "118"
    }
    case object InvalidBigInt extends CryptoErrorCode {
      override val code: String = "107"
    }
    case object InvalidFactorizeChallenge extends CryptoErrorCode {
      override val code: String = "106"
    }
    case object InvalidKey extends CryptoErrorCode {
      override val code: String = "102"
    }
    case object InvalidKeySize extends CryptoErrorCode {
      override val code: String = "109"
    }
    case object InvalidPublicKey extends CryptoErrorCode {
      override val code: String = "100"
    }
    case object InvalidSecretKey extends CryptoErrorCode {
      override val code: String = "101"
    }
    case object MnemonicFromEntropyFailed extends CryptoErrorCode {
      override val code: String = "120"
    }
    case object MnemonicGenerationFailed extends CryptoErrorCode {
      override val code: String = "119"
    }
    case object NaclBoxFailed extends CryptoErrorCode {
      override val code: String = "111"
    }
    case object NaclSecretBoxFailed extends CryptoErrorCode {
      override val code: String = "110"
    }
    case object NaclSignFailed extends CryptoErrorCode {
      override val code: String = "112"
    }
    case object ScryptFailed extends CryptoErrorCode {
      override val code: String = "108"
    }
    case object SigningBoxNotRegistered extends CryptoErrorCode {
      override val code: String = "121"
    }
  }
  case class KeyPair(public: String, secret: String)
  /** Signing box callbacks. */
  sealed trait ParamsOfAppSigningBox
  object ParamsOfAppSigningBox {
    /** Get signing box public key */
    case object GetPublicKey extends ParamsOfAppSigningBox
    /** Signing box callbacks. */
    case class Sign(unsigned: String) extends ParamsOfAppSigningBox
  }
  case class ParamsOfChaCha20(data: String, key: String, nonce: String)
  case class ParamsOfConvertPublicKeyToTonSafeFormat(public_key: String)
  case class ParamsOfFactorize(composite: String)
  case class ParamsOfGenerateRandomBytes(length: Long)
  case class ParamsOfHDKeyDeriveFromXPrv(xprv: String, child_index: Long, hardened: Boolean)
  case class ParamsOfHDKeyDeriveFromXPrvPath(xprv: String, path: String)
  case class ParamsOfHDKeyPublicFromXPrv(xprv: String)
  case class ParamsOfHDKeySecretFromXPrv(xprv: String)
  case class ParamsOfHDKeyXPrvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfHash(data: String)
  case class ParamsOfMnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicWords(dictionary: Option[Long])
  case class ParamsOfModularPower(base: String, exponent: String, modulus: String)
  case class ParamsOfNaclBox(decrypted: String, nonce: String, their_public: String, secret: String)
  case class ParamsOfNaclBoxKeyPairFromSecret(secret: String)
  case class ParamsOfNaclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String)
  case class ParamsOfNaclSecretBox(decrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSecretBoxOpen(encrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSign(unsigned: String, secret: String)
  case class ParamsOfNaclSignKeyPairFromSecret(secret: String)
  case class ParamsOfNaclSignOpen(signed: String, public: String)
  case class ParamsOfScrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long)
  case class ParamsOfSign(unsigned: String, keys: KeyPair)
  case class ParamsOfSigningBoxSign(signing_box: SigningBoxHandle, unsigned: String)
  case class ParamsOfTonCrc16(data: String)
  case class ParamsOfVerifySignature(signed: String, public: String)
  case class RegisteredSigningBox(handle: SigningBoxHandle)
  /** Returning values from signing box callbacks. */
  sealed trait ResultOfAppSigningBox
  object ResultOfAppSigningBox {
    /** Returning values from signing box callbacks. */
    case class GetPublicKey(public_key: String) extends ResultOfAppSigningBox
    /** Returning values from signing box callbacks. */
    case class Sign(signature: String) extends ResultOfAppSigningBox
  }
  case class ResultOfChaCha20(data: String)
  case class ResultOfConvertPublicKeyToTonSafeFormat(ton_public_key: String)
  case class ResultOfFactorize(factors: List[String])
  case class ResultOfGenerateRandomBytes(bytes: String)
  case class ResultOfHDKeyDeriveFromXPrv(xprv: String)
  case class ResultOfHDKeyDeriveFromXPrvPath(xprv: String)
  case class ResultOfHDKeyPublicFromXPrv(public: String)
  case class ResultOfHDKeySecretFromXPrv(secret: String)
  case class ResultOfHDKeyXPrvFromMnemonic(xprv: String)
  case class ResultOfHash(hash: String)
  case class ResultOfMnemonicFromEntropy(phrase: String)
  case class ResultOfMnemonicFromRandom(phrase: String)
  case class ResultOfMnemonicVerify(valid: Boolean)
  case class ResultOfMnemonicWords(words: String)
  case class ResultOfModularPower(modular_power: String)
  case class ResultOfNaclBox(encrypted: String)
  case class ResultOfNaclBoxOpen(decrypted: String)
  case class ResultOfNaclSign(signed: String)
  case class ResultOfNaclSignDetached(signature: String)
  case class ResultOfNaclSignOpen(unsigned: String)
  case class ResultOfScrypt(key: String)
  case class ResultOfSign(signed: String, signature: String)
  case class ResultOfSigningBoxGetPublicKey(pubkey: String)
  case class ResultOfSigningBoxSign(signature: String)
  case class ResultOfTonCrc16(crc: Long)
  case class ResultOfVerifySignature(unsigned: String)
  case class SigningBoxHandle(value: BigInt)
}
package crypto {
  /**
   * Performs symmetric `chacha20` encryption.
   * @param data Must be encoded with `base64`.
   * @param key Must be encoded with `hex`.
   * @param nonce Must be encoded with `hex`.
   */
  def chacha20(data: String, key: String, nonce: String): Future[Either[Throwable, ResultOfChaCha20]]
  /**
   * Converts public key to ton safe_format
   * @param public_key
   */
  def convertPublicKeyToTonSafeFormat(public_key: String): Future[Either[Throwable, ResultOfConvertPublicKeyToTonSafeFormat]]
  /**
   * Performs prime factorization â€“ decomposition of a composite number into a product of smaller prime integers (factors). See [https://en.wikipedia.org/wiki/Integer_factorization]
   * @param composite
   */
  def factorize(composite: String): Future[Either[Throwable, ResultOfFactorize]]
  /**
   * Generates random byte array of the specified length and returns it in `base64` format
   * @param length
   */
  def generateRandomBytes(length: Long): Future[Either[Throwable, ResultOfGenerateRandomBytes]]
  /** Generates random ed25519 key pair. */
  def generateRandomSignKeys(): Future[Either[Throwable, KeyPair]]
  /**
   * Creates a default signing box implementation.
   * @param public
   * @param secret
   */
  def getSigningBox(public: String, secret: String): Future[Either[Throwable, RegisteredSigningBox]]
  /**
   * Returns extended private key derived from the specified extended private key and child index
   * @param xprv
   * @param child_index
   * @param hardened
   */
  def hdkeyDeriveFromXprv(xprv: String, child_index: Long, hardened: Boolean): Future[Either[Throwable, ResultOfHDKeyDeriveFromXPrv]]
  /**
   * Derives the extended private key from the specified key and path
   * @param xprv
   * @param path
   */
  def hdkeyDeriveFromXprvPath(xprv: String, path: String): Future[Either[Throwable, ResultOfHDKeyDeriveFromXPrvPath]]
  /**
   * Extracts the public key from the serialized extended private key
   * @param xprv
   */
  def hdkeyPublicFromXprv(xprv: String): Future[Either[Throwable, ResultOfHDKeyPublicFromXPrv]]
  /**
   * Extracts the private key from the serialized extended private key
   * @param xprv
   */
  def hdkeySecretFromXprv(xprv: String): Future[Either[Throwable, ResultOfHDKeySecretFromXPrv]]
  /**
   * Generates an extended master private key that will be the root for all the derived keys
   * @param phrase
   * @param dictionary
   * @param word_count
   */
  def hdkeyXprvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfHDKeyXPrvFromMnemonic]]
  /**
   * Validates the seed phrase, generates master key and then derives the key pair from the master key and the specified path
   * @param phrase
   * @param path
   * @param dictionary
   * @param word_count
   */
  def mnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, KeyPair]]
  /**
   * Generates mnemonic from pre-generated entropy
   * @param entropy Hex encoded.
   * @param dictionary
   * @param word_count
   */
  def mnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicFromEntropy]]
  /**
   * Generates a random mnemonic from the specified dictionary and word count
   * @param dictionary
   * @param word_count
   */
  def mnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicFromRandom]]
  /**
   * The phrase supplied will be checked for word length and validated according to the checksum specified in BIP0039.
   * @param phrase
   * @param dictionary
   * @param word_count
   */
  def mnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicVerify]]
  /**
   * Prints the list of words from the specified dictionary
   * @param dictionary
   */
  def mnemonicWords(dictionary: Option[Long]): Future[Either[Throwable, ResultOfMnemonicWords]]
  /**
   * Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`). See [https://en.wikipedia.org/wiki/Modular_exponentiation]
   * @param base
   * @param exponent
   * @param modulus
   */
  def modularPower(base: String, exponent: String, modulus: String): Future[Either[Throwable, ResultOfModularPower]]
  /**
   * Public key authenticated encryption
   * Encrypt and authenticate a message using the senders secret key, the recievers public
   * key, and a nonce.
   * @param decrypted
   * @param nonce
   * @param their_public
   * @param secret
   */
  def naclBox(decrypted: String, nonce: String, their_public: String, secret: String): Future[Either[Throwable, ResultOfNaclBox]]
  /** Generates a random NaCl key pair */
  def naclBoxKeypair(): Future[Either[Throwable, KeyPair]]
  /**
   * Generates key pair from a secret key
   * @param secret
   */
  def naclBoxKeypairFromSecretKey(secret: String): Future[Either[Throwable, KeyPair]]
  /**
   * Decrypt and verify the cipher text using the recievers secret key, the senders public key, and the nonce.
   * @param encrypted Encoded with `base64`.
   * @param nonce
   * @param their_public
   * @param secret
   */
  def naclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String): Future[Either[Throwable, ResultOfNaclBoxOpen]]
  /**
   * Encrypt and authenticate message using nonce and secret key.
   * @param decrypted Encoded with `base64`.
   * @param nonce
   * @param key
   */
  def naclSecretBox(decrypted: String, nonce: String, key: String): Future[Either[Throwable, ResultOfNaclBox]]
  /**
   * Decrypts and verifies cipher text using `nonce` and secret `key`.
   * @param encrypted Encoded with `base64`.
   * @param nonce
   * @param key
   */
  def naclSecretBoxOpen(encrypted: String, nonce: String, key: String): Future[Either[Throwable, ResultOfNaclBoxOpen]]
  /**
   * Signs data using the signer's secret key.
   * @param unsigned
   * @param secret
   */
  def naclSign(unsigned: String, secret: String): Future[Either[Throwable, ResultOfNaclSign]]
  /**
   * Signs the message using the secret key and returns a signature.
   * Signs the message `unsigned` using the secret key `secret`
   * and returns a signature `signature`.
   * @param unsigned
   * @param secret
   */
  def naclSignDetached(unsigned: String, secret: String): Future[Either[Throwable, ResultOfNaclSignDetached]]
  /**
   * Generates a key pair for signing from the secret key
   * @param secret
   */
  def naclSignKeypairFromSecretKey(secret: String): Future[Either[Throwable, KeyPair]]
  /**
   * Verifies the signature and returns the unsigned message
   * Verifies the signature in `signed` using the signer's public key `public`
   * and returns the message `unsigned`.
   *
   * If the signature fails verification, crypto_sign_open raises an exception.
   * @param signed Encoded with `base64`.
   * @param public
   */
  def naclSignOpen(signed: String, public: String): Future[Either[Throwable, ResultOfNaclSignOpen]]
  /**
   * Register an application implemented signing box.
   * @param app_object
   */
  def registerSigningBox(app_object: ParamsOfAppSigningBox => ResultOfAppSigningBox): Future[Either[Throwable, RegisteredSigningBox]]
  /**
   * Removes signing box from SDK.
   * @param handle
   */
  def removeSigningBox(handle: SigningBoxHandle): Future[Either[Throwable, Unit]]
  /**
   * Derives key from `password` and `key` using `scrypt` algorithm. See [https://en.wikipedia.org/wiki/Scrypt].
   * # Arguments
   * - `log_n` - The log2 of the Scrypt parameter `N`
   * - `r` - The Scrypt parameter `r`
   * - `p` - The Scrypt parameter `p`
   * # Conditions
   * - `log_n` must be less than `64`
   * - `r` must be greater than `0` and less than or equal to `4294967295`
   * - `p` must be greater than `0` and less than `4294967295`
   * # Recommended values sufficient for most use-cases
   * - `log_n = 15` (`n = 32768`)
   * - `r = 8`
   * - `p = 1`
   * @param password
   * @param salt
   * @param log_n
   * @param r
   * @param p
   * @param dk_len
   */
  def scrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long): Future[Either[Throwable, ResultOfScrypt]]
  /**
   * Calculates SHA256 hash of the specified data.
   * @param data Encoded with `base64`.
   */
  def sha256(data: String): Future[Either[Throwable, ResultOfHash]]
  /**
   * Calculates SHA512 hash of the specified data.
   * @param data Encoded with `base64`.
   */
  def sha512(data: String): Future[Either[Throwable, ResultOfHash]]
  /**
   * Signs a data using the provided keys.
   * @param unsigned
   * @param keys
   */
  def sign(unsigned: String, keys: KeyPair): Future[Either[Throwable, ResultOfSign]]
  /**
   * Returns public key of signing key pair.
   * @param handle
   */
  def signingBoxGetPublicKey(handle: SigningBoxHandle): Future[Either[Throwable, ResultOfSigningBoxGetPublicKey]]
  /**
   * Returns signed user data.
   * @param signing_box
   * @param unsigned Must be encoded with `base64`.
   */
  def signingBoxSign(signing_box: SigningBoxHandle, unsigned: String): Future[Either[Throwable, ResultOfSigningBoxSign]]
  /**
   * Calculates CRC16 using TON algorithm.
   * @param data Encoded with `base64`.
   */
  def tonCrc16(data: String): Future[Either[Throwable, ResultOfTonCrc16]]
  /**
   * Verifies signed data using the provided public key. Raises error if verification is failed.
   * @param signed
   * @param public
   */
  def verifySignature(signed: String, public: String): Future[Either[Throwable, ResultOfVerifySignature]]
}
package abi {
  sealed trait Abi
  object Abi {
    case class Contract(value: AbiContract) extends Abi
    case class Handle(value: AbiHandle) extends Abi
    case class Json(value: String) extends Abi
    case class Serialized(value: AbiContract) extends Abi
  }
  case class AbiContract(`ABI version`: Option[Long], abi_version: Option[Long], header: Option[List[String]], functions: Option[List[AbiFunction]], events: Option[List[AbiEvent]], data: Option[List[AbiData]])
  case class AbiData(key: BigInt, name: String, `type`: String, components: Option[List[AbiParam]])
  sealed trait AbiErrorCode {
    val code: String
  }
  object AbiErrorCode {
    case object AttachSignatureFailed extends AbiErrorCode {
      override val code: String = "307"
    }
    case object EncodeDeployMessageFailed extends AbiErrorCode {
      override val code: String = "305"
    }
    case object EncodeRunMessageFailed extends AbiErrorCode {
      override val code: String = "306"
    }
    case object InvalidAbi extends AbiErrorCode {
      override val code: String = "311"
    }
    case object InvalidJson extends AbiErrorCode {
      override val code: String = "303"
    }
    case object InvalidMessage extends AbiErrorCode {
      override val code: String = "304"
    }
    case object InvalidSigner extends AbiErrorCode {
      override val code: String = "310"
    }
    case object InvalidTvcImage extends AbiErrorCode {
      override val code: String = "308"
    }
    case object RequiredAddressMissingForEncodeMessage extends AbiErrorCode {
      override val code: String = "301"
    }
    case object RequiredCallSetMissingForEncodeMessage extends AbiErrorCode {
      override val code: String = "302"
    }
    case object RequiredPublicKeyMissingForFunctionHeader extends AbiErrorCode {
      override val code: String = "309"
    }
  }
  case class AbiEvent(name: String, inputs: List[AbiParam], id: Option[Option[String]])
  case class AbiFunction(name: String, inputs: List[AbiParam], outputs: List[AbiParam], id: Option[Option[String]])
  case class AbiHandle(value: BigInt)
  case class AbiParam(name: String, `type`: String, components: Option[List[AbiParam]])
  case class CallSet(function_name: String, header: Option[FunctionHeader], input: Option[Value])
  case class DecodedMessageBody(body_type: MessageBodyType, name: String, value: Option[Value], header: Option[FunctionHeader])
  case class DeploySet(tvc: String, workchain_id: Option[Int], initial_data: Option[Value])
  /**
   * The ABI function header.
   * Includes several hidden function parameters that contract
   * uses for security, message delivery monitoring and replay protection reasons.
   *
   * The actual set of header fields depends on the contract's ABI.
   * If a contract's ABI does not include some headers, then they are not filled.
   */
  case class FunctionHeader(expire: Option[Long], time: Option[BigInt], pubkey: Option[String])
  sealed trait MessageBodyType
  object MessageBodyType {
    /** Message contains the input of the ABI event. */
    case object Event extends MessageBodyType
    /** Message contains the input of the ABI function. */
    case object Input extends MessageBodyType
    /**
     * Message contains the input of the imported ABI function.
     * Occurs when contract sends an internal message to other
     * contract.
     */
    case object InternalOutput extends MessageBodyType
    /** Message contains the output of the ABI function. */
    case object Output extends MessageBodyType
  }
  sealed trait MessageSource
  object MessageSource {
    case class Encoded(message: String, abi: Option[Abi]) extends MessageSource
    case class EncodingParams(value: ParamsOfEncodeMessage) extends MessageSource
  }
  case class ParamsOfAttachSignature(abi: Abi, public_key: String, message: String, signature: String)
  case class ParamsOfAttachSignatureToMessageBody(abi: Abi, public_key: String, message: String, signature: String)
  case class ParamsOfDecodeMessage(abi: Abi, message: String)
  case class ParamsOfDecodeMessageBody(abi: Abi, body: String, is_internal: Boolean)
  case class ParamsOfEncodeAccount(state_init: StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long])
  case class ParamsOfEncodeMessage(abi: Abi, address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], signer: Signer, processing_try_index: Option[Long])
  case class ParamsOfEncodeMessageBody(abi: Abi, call_set: CallSet, is_internal: Boolean, signer: Signer, processing_try_index: Option[Long])
  case class ResultOfAttachSignature(message: String, message_id: String)
  case class ResultOfAttachSignatureToMessageBody(body: String)
  case class ResultOfEncodeAccount(account: String, id: String)
  case class ResultOfEncodeMessage(message: String, data_to_sign: Option[String], address: String, message_id: String)
  case class ResultOfEncodeMessageBody(body: String, data_to_sign: Option[String])
  sealed trait Signer
  object Signer {
    case class External(public_key: String) extends Signer
    case class Keys(keys: KeyPair) extends Signer
    /**
     * No keys are provided.
     * Creates an unsigned message.
     */
    case object None extends Signer
    case class SigningBox(handle: SigningBoxHandle) extends Signer
  }
  case class StateInitParams(abi: Abi, value: Value)
  sealed trait StateInitSource
  object StateInitSource {
    case class Message(source: MessageSource) extends StateInitSource
    case class StateInit(code: String, data: String, library: Option[String]) extends StateInitSource
    case class Tvc(tvc: String, public_key: Option[String], init_params: Option[StateInitParams]) extends StateInitSource
  }
}
package abi {
  /**
   * Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`. Returns signed message encoded in `base64`.
   * @param abi
   * @param public_key
   * @param message
   * @param signature
   */
  def attachSignature(abi: Abi, public_key: String, message: String, signature: String): Future[Either[Throwable, ResultOfAttachSignature]]
  /**
   * @param abi
   * @param public_key Must be encoded with `hex`.
   * @param message Must be encoded with `base64`.
   * @param signature Must be encoded with `hex`.
   */
  def attachSignatureToMessageBody(abi: Abi, public_key: String, message: String, signature: String): Future[Either[Throwable, ResultOfAttachSignatureToMessageBody]]
  /**
   * Decodes message body using provided message BOC and ABI.
   * @param abi
   * @param message
   */
  def decodeMessage(abi: Abi, message: String): Future[Either[Throwable, DecodedMessageBody]]
  /**
   * Decodes message body using provided body BOC and ABI.
   * @param abi
   * @param body
   * @param is_internal
   */
  def decodeMessageBody(abi: Abi, body: String, is_internal: Boolean): Future[Either[Throwable, DecodedMessageBody]]
  /**
   * Creates account state BOC
   * Creates account state provided with one of these sets of data :
   * 1. BOC of code, BOC of data, BOC of library
   * 2. TVC (string in `base64`), keys, init params
   * @param state_init
   * @param balance
   * @param last_trans_lt
   * @param last_paid
   */
  def encodeAccount(state_init: StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long]): Future[Either[Throwable, ResultOfEncodeAccount]]
  /**
   * Encodes an ABI-compatible message
   * Allows to encode deploy and function call messages,
   * both signed and unsigned.
   *
   * Use cases include messages of any possible type:
   * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
   * of initialization);
   * - deploy without initial function call;
   * - signed/unsigned + data for signing.
   *
   * `Signer` defines how the message should or shouldn't be signed:
   *
   * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,
   * that do not require authorization by pubkey.
   *
   * `Signer::External` takes public key and returns `data_to_sign` for later signing.
   * Use `attach_signature` method with the result signature to get the signed message.
   *
   * `Signer::Keys` creates a signed message with provided key pair.
   *
   * [SOON] `Signer::SigningBox` Allows using a special interface to imlepement signing
   * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,
   * when application calls some API to sign data.
   * @param abi
   * @param address Must be specified in case of non-deploy message.
   * @param deploy_set Must be specified in case of deploy message.
   * @param call_set Must be specified in case of non-deploy message.
   *
   * In case of deploy message it is optional and contains parameters
   * of the functions that will to be called upon deploy transaction.
   * @param signer
   * @param processing_try_index Used in message processing with retries (if contract's ABI includes "expire" header).
   *
   * Encoder uses the provided try index to calculate message
   * expiration time. The 1st message expiration time is specified in
   * Client config.
   *
   * Expiration timeouts will grow with every retry.
   * Retry grow factor is set in Client config:
   * <.....add config parameter with default value here>
   *
   * Default value is 0.
   */
  def encodeMessage(abi: Abi, address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], signer: Signer, processing_try_index: Option[Long]): Future[Either[Throwable, ResultOfEncodeMessage]]
  /**
   * Encodes message body according to ABI function call.
   * @param abi
   * @param call_set Must be specified in non deploy message.
   *
   * In case of deploy message contains parameters of constructor.
   * @param is_internal
   * @param signer
   * @param processing_try_index Used in message processing with retries.
   *
   * Encoder uses the provided try index to calculate message
   * expiration time.
   *
   * Expiration timeouts will grow with every retry.
   *
   * Default value is 0.
   */
  def encodeMessageBody(abi: Abi, call_set: CallSet, is_internal: Boolean, signer: Signer, processing_try_index: Option[Long]): Future[Either[Throwable, ResultOfEncodeMessageBody]]
}
package boc {
  sealed trait BocErrorCode {
    val code: String
  }
  object BocErrorCode {
    case object InappropriateBlock extends BocErrorCode {
      override val code: String = "203"
    }
    case object InvalidBoc extends BocErrorCode {
      override val code: String = "201"
    }
    case object MissingSourceBoc extends BocErrorCode {
      override val code: String = "204"
    }
    case object SerializationError extends BocErrorCode {
      override val code: String = "202"
    }
  }
  case class ParamsOfGetBlockchainConfig(block_boc: String)
  case class ParamsOfGetBocHash(boc: String)
  case class ParamsOfGetCodeFromTvc(tvc: String)
  case class ParamsOfParse(boc: String)
  case class ParamsOfParseShardstate(boc: String, id: String, workchain_id: Int)
  case class ResultOfGetBlockchainConfig(config_boc: String)
  case class ResultOfGetBocHash(hash: String)
  case class ResultOfGetCodeFromTvc(code: String)
  case class ResultOfParse(parsed: Value)
}
package boc {
  /** @param block_boc  */
  def getBlockchainConfig(block_boc: String): Future[Either[Throwable, ResultOfGetBlockchainConfig]]
  /**
   * Calculates BOC root hash
   * @param boc
   */
  def getBocHash(boc: String): Future[Either[Throwable, ResultOfGetBocHash]]
  /**
   * Extracts code from TVC contract image
   * @param tvc
   */
  def getCodeFromTvc(tvc: String): Future[Either[Throwable, ResultOfGetCodeFromTvc]]
  /**
   * Parses account boc into a JSON
   * JSON structure is compatible with GraphQL API account object
   * @param boc
   */
  def parseAccount(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses block boc into a JSON
   * JSON structure is compatible with GraphQL API block object
   * @param boc
   */
  def parseBlock(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses message boc into a JSON
   * JSON structure is compatible with GraphQL API message object
   * @param boc
   */
  def parseMessage(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses shardstate boc into a JSON
   * JSON structure is compatible with GraphQL API shardstate object
   * @param boc
   * @param id
   * @param workchain_id
   */
  def parseShardstate(boc: String, id: String, workchain_id: Int): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses transaction boc into a JSON
   * JSON structure is compatible with GraphQL API transaction object
   * @param boc
   */
  def parseTransaction(boc: String): Future[Either[Throwable, ResultOfParse]]
}
package processing {
  case class DecodedOutput(out_messages: List[Option[DecodedMessageBody]], output: Option[Value])
  case class ParamsOfProcessMessage(message_encode_params: ParamsOfEncodeMessage, send_events: Boolean)
  case class ParamsOfSendMessage(message: String, abi: Option[Abi], send_events: Boolean)
  case class ParamsOfWaitForTransaction(abi: Option[Abi], message: String, shard_block_id: String, send_events: Boolean)
  sealed trait ProcessingErrorCode {
    val code: String
  }
  object ProcessingErrorCode {
    case object BlockNotFound extends ProcessingErrorCode {
      override val code: String = "511"
    }
    case object CanNotBuildMessageCell extends ProcessingErrorCode {
      override val code: String = "503"
    }
    case object CanNotCheckBlockShard extends ProcessingErrorCode {
      override val code: String = "510"
    }
    case object ExternalSignerMustNotBeUsed extends ProcessingErrorCode {
      override val code: String = "513"
    }
    case object FetchBlockFailed extends ProcessingErrorCode {
      override val code: String = "504"
    }
    case object InvalidBlockReceived extends ProcessingErrorCode {
      override val code: String = "509"
    }
    case object InvalidData extends ProcessingErrorCode {
      override val code: String = "512"
    }
    case object InvalidMessageBoc extends ProcessingErrorCode {
      override val code: String = "506"
    }
    case object MessageAlreadyExpired extends ProcessingErrorCode {
      override val code: String = "501"
    }
    case object MessageExpired extends ProcessingErrorCode {
      override val code: String = "507"
    }
    case object MessageHasNotDestinationAddress extends ProcessingErrorCode {
      override val code: String = "502"
    }
    case object SendMessageFailed extends ProcessingErrorCode {
      override val code: String = "505"
    }
    case object TransactionWaitTimeout extends ProcessingErrorCode {
      override val code: String = "508"
    }
  }
  sealed trait ProcessingEvent
  object ProcessingEvent {
    case class DidSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
    case class FetchFirstBlockFailed(error: ClientError) extends ProcessingEvent
    case class FetchNextBlockFailed(shard_block_id: String, message_id: String, message: String, error: ClientError) extends ProcessingEvent
    case class MessageExpired(message_id: String, message: String, error: ClientError) extends ProcessingEvent
    case class SendFailed(shard_block_id: String, message_id: String, message: String, error: ClientError) extends ProcessingEvent
    /**
     * Notifies the app that the current shard block will be fetched from the network.
     * Fetched block will be used later in waiting phase.
     */
    case object WillFetchFirstBlock extends ProcessingEvent
    case class WillFetchNextBlock(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
    case class WillSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  }
  case class ResultOfProcessMessage(transaction: Value, out_messages: List[String], decoded: Option[DecodedOutput], fees: TransactionFees)
  case class ResultOfSendMessage(shard_block_id: String)
}
package processing {
  /**
   * Creates message, sends it to the network and monitors its processing.
   * Creates ABI-compatible message,
   * sends it to the network and monitors for the result transaction.
   * Decodes the output messages' bodies.
   *
   * If contract's ABI includes "expire" header, then
   * SDK implements retries in case of unsuccessful message delivery within the expiration
   * timeout: SDK recreates the message, sends it and processes it again.
   *
   * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,
   * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag
   * and logged into the supplied callback function.
   * The retry configuration parameters are defined in client's `NetworkConfig`.
   *
   * If contract's ABI does not include "expire" header
   * then, if no transaction is found within the network timeout (see config parameter ), exits with error.
   * @param message_encode_params
   * @param send_events
   * @param request
   */
  def processMessage(message_encode_params: ParamsOfEncodeMessage, send_events: Boolean, request: Request): Future[Either[Throwable, ResultOfProcessMessage]]
  /**
   * Sends message to the network and returns the last generated shard block of the destination account
   * before the message was sent. It will be required later for message processing.
   * @param message
   * @param abi If this parameter is specified and the message has the
   * `expire` header then expiration time will be checked against
   * the current time to prevent unnecessary sending of already expired message.
   *
   * The `message already expired` error will be returned in this
   * case.
   *
   * Note, that specifying `abi` for ABI compliant contracts is
   * strongly recommended, so that proper processing strategy can be
   * chosen.
   * @param send_events
   * @param callback
   */
  def sendMessage(message: String, abi: Option[Abi], send_events: Boolean, callback: Request): Future[Either[Throwable, ResultOfSendMessage]]
  /**
   * Performs monitoring of the network for the result transaction of the external inbound message processing.
   * `send_events` enables intermediate events, such as `WillFetchNextBlock`,
   * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation
   * during message processing.
   *
   * Note, that presence of the `abi` parameter is critical for ABI
   * compliant contracts. Message processing uses drastically
   * different strategy for processing message for contracts which
   * ABI includes "expire" header.
   *
   * When the ABI header `expire` is present, the processing uses
   * `message expiration` strategy:
   * - The maximum block gen time is set to
   *   `message_expiration_timeout + transaction_wait_timeout`.
   * - When maximum block gen time is reached, the processing will
   *   be finished with `MessageExpired` error.
   *
   * When the ABI header `expire` isn't present or `abi` parameter
   * isn't specified, the processing uses `transaction waiting`
   * strategy:
   * - The maximum block gen time is set to
   *   `now() + transaction_wait_timeout`.
   *
   * - If maximum block gen time is reached and no result transaction is found,
   * the processing will exit with an error.
   * @param abi If it is specified, then the output messages' bodies will be
   * decoded according to this ABI.
   *
   * The `abi_decoded` result field will be filled out.
   * @param message Encoded with `base64`.
   * @param shard_block_id You must provide the same value as the `send_message` has returned.
   * @param send_events
   * @param callback
   */
  def waitForTransaction(abi: Option[Abi], message: String, shard_block_id: String, send_events: Boolean, callback: Request): Future[Either[Throwable, ResultOfProcessMessage]]
}
package utils {
  sealed trait AddressStringFormat
  object AddressStringFormat {
    case object AccountId extends AddressStringFormat
    case class Base64(url: Boolean, test: Boolean, bounce: Boolean) extends AddressStringFormat
    case object Hex extends AddressStringFormat
  }
  case class ParamsOfConvertAddress(address: String, output_format: AddressStringFormat)
  case class ResultOfConvertAddress(address: String)
}
package utils {
  /**
   * Converts address from any TON format to any TON format
   * @param address
   * @param output_format
   */
  def convertAddress(address: String, output_format: AddressStringFormat): Future[Either[Throwable, ResultOfConvertAddress]]
}
package tvm {
  sealed trait AccountForExecutor
  object AccountForExecutor {
    case class Account(boc: String, unlimited_balance: Option[Boolean]) extends AccountForExecutor
    /** Non-existing account to run a creation internal message. Should be used with `skip_transaction_check = true` if the message has no deploy data since transactions on the uninitialized account are always aborted */
    case object None extends AccountForExecutor
    /** Emulate uninitialized account to run deploy message */
    case object Uninit extends AccountForExecutor
  }
  case class ExecutionOptions(blockchain_config: Option[String], block_time: Option[Long], block_lt: Option[BigInt], transaction_lt: Option[BigInt])
  case class ParamsOfRunExecutor(message: String, account: AccountForExecutor, execution_options: Option[ExecutionOptions], abi: Option[Abi], skip_transaction_check: Option[Boolean])
  case class ParamsOfRunGet(account: String, function_name: String, input: Option[Value], execution_options: Option[ExecutionOptions])
  case class ParamsOfRunTvm(message: String, account: String, execution_options: Option[ExecutionOptions], abi: Option[Abi])
  case class ResultOfRunExecutor(transaction: Value, out_messages: List[String], decoded: Option[DecodedOutput], account: String, fees: TransactionFees)
  case class ResultOfRunGet(output: Value)
  case class ResultOfRunTvm(out_messages: List[String], decoded: Option[DecodedOutput], account: String)
  case class TransactionFees(in_msg_fwd_fee: BigInt, storage_fee: BigInt, gas_fee: BigInt, out_msgs_fwd_fee: BigInt, total_account_fees: BigInt, total_output: BigInt)
  sealed trait TvmErrorCode {
    val code: String
  }
  object TvmErrorCode {
    case object AccountCodeMissing extends TvmErrorCode {
      override val code: String = "406"
    }
    case object AccountFrozenOrDeleted extends TvmErrorCode {
      override val code: String = "408"
    }
    case object AccountMissing extends TvmErrorCode {
      override val code: String = "409"
    }
    case object ActionPhaseFailed extends TvmErrorCode {
      override val code: String = "405"
    }
    case object CanNotReadBlockchainConfig extends TvmErrorCode {
      override val code: String = "402"
    }
    case object CanNotReadTransaction extends TvmErrorCode {
      override val code: String = "401"
    }
    case object ContractExecutionError extends TvmErrorCode {
      override val code: String = "414"
    }
    case object InternalError extends TvmErrorCode {
      override val code: String = "404"
    }
    case object InvalidAccountBoc extends TvmErrorCode {
      override val code: String = "412"
    }
    case object InvalidInputStack extends TvmErrorCode {
      override val code: String = "411"
    }
    case object InvalidMessageType extends TvmErrorCode {
      override val code: String = "413"
    }
    case object LowBalance extends TvmErrorCode {
      override val code: String = "407"
    }
    case object TransactionAborted extends TvmErrorCode {
      override val code: String = "403"
    }
    case object UnknownExecutionError extends TvmErrorCode {
      override val code: String = "410"
    }
  }
}
package tvm {
  /**
   * Emulates all the phases of contract execution locally
   * Performs all the phases of contract execution on Transaction Executor -
   * the same component that is used on Validator Nodes.
   *
   * Can be used for contract debug, to find out the reason of message unsuccessful
   * delivery - as Validators just throw away failed transactions, here you can catch it.
   *
   * Another use case is to estimate fees for message execution. Set  `AccountForExecutor::Account.unlimited_balance`
   * to `true` so that emulation will not depend on the actual balance.
   *
   * One more use case - you can procude the sequence of operations,
   * thus emulating the multiple contract calls locally.
   * And so on.
   *
   * To get the account boc (bag of cells) - use `net.query` method to download it from graphql api
   * (field `boc` of `account`) or generate it with `abi.encode_account method`.
   * To get the message boc - use `abi.encode_message` or prepare it any other way, for instance, with Fift script.
   *
   * If you need this emulation to be as precise as possible then specify `ParamsOfRunExecutor` parameter.
   * If you need to see the aborted transaction as a result, not as an error, set `skip_transaction_check` to `true`.
   * @param message Must be encoded as base64.
   * @param account
   * @param execution_options
   * @param abi
   * @param skip_transaction_check
   */
  def runExecutor(message: String, account: AccountForExecutor, execution_options: Option[ExecutionOptions], abi: Option[Abi], skip_transaction_check: Option[Boolean]): Future[Either[Throwable, ResultOfRunExecutor]]
  /**
   * Executes a getmethod of FIFT contract that fulfills the smc-guidelines https://test.ton.org/smc-guidelines.txt
   * and returns the result data from TVM's stack
   * @param account
   * @param function_name
   * @param input
   * @param execution_options
   */
  def runGet(account: String, function_name: String, input: Option[Value], execution_options: Option[ExecutionOptions]): Future[Either[Throwable, ResultOfRunGet]]
  /**
   * Executes get methods of ABI-compatible contracts
   * Performs only a part of compute phase of transaction execution
   * that is used to run get-methods of ABI-compatible contracts.
   *
   * If you try to run get methods with `run_executor` you will get an error, because it checks ACCEPT and exits
   * if there is none, which is actually true for get methods.
   *
   *  To get the account boc (bag of cells) - use `net.query` method to download it from graphql api
   * (field `boc` of `account`) or generate it with `abi.encode_account method`.
   * To get the message boc - use `abi.encode_message` or prepare it any other way, for instance, with Fift script.
   *
   * Attention! Updated account state is produces as well, but only
   * `account_state.storage.state.data`  part of the boc is updated.
   * @param message Must be encoded as base64.
   * @param account Must be encoded as base64.
   * @param execution_options
   * @param abi
   */
  def runTvm(message: String, account: String, execution_options: Option[ExecutionOptions], abi: Option[Abi]): Future[Either[Throwable, ResultOfRunTvm]]
}
package net {
  case class EndpointsSet(endpoints: List[String])
  sealed trait NetErrorCode {
    val code: String
  }
  object NetErrorCode {
    case object ClockOutOfSync extends NetErrorCode {
      override val code: String = "606"
    }
    case object GetSubscriptionResultFailed extends NetErrorCode {
      override val code: String = "604"
    }
    case object GraphqlError extends NetErrorCode {
      override val code: String = "608"
    }
    case object InvalidServerResponse extends NetErrorCode {
      override val code: String = "605"
    }
    case object NetworkModuleSuspended extends NetErrorCode {
      override val code: String = "609"
    }
    case object NoEndpointsProvided extends NetErrorCode {
      override val code: String = "612"
    }
    case object NotSupported extends NetErrorCode {
      override val code: String = "611"
    }
    case object QueryFailed extends NetErrorCode {
      override val code: String = "601"
    }
    case object SubscribeFailed extends NetErrorCode {
      override val code: String = "602"
    }
    case object WaitForFailed extends NetErrorCode {
      override val code: String = "603"
    }
    case object WaitForTimeout extends NetErrorCode {
      override val code: String = "607"
    }
    case object WebsocketDisconnected extends NetErrorCode {
      override val code: String = "610"
    }
  }
  case class OrderBy(path: String, direction: SortDirection)
  case class ParamsOfFindLastShardBlock(address: String)
  case class ParamsOfQuery(query: String, variables: Option[Value])
  case class ParamsOfQueryCollection(collection: String, filter: Option[Value], result: String, order: Option[List[OrderBy]], limit: Option[Long])
  case class ParamsOfSubscribeCollection(collection: String, filter: Option[Value], result: String)
  case class ParamsOfWaitForCollection(collection: String, filter: Option[Value], result: String, timeout: Option[Long])
  case class ResultOfFindLastShardBlock(block_id: String)
  case class ResultOfQuery(result: Value)
  case class ResultOfQueryCollection(result: List[Value])
  case class ResultOfSubscribeCollection(handle: Long)
  case class ResultOfWaitForCollection(result: Value)
  sealed trait SortDirection
  object SortDirection {
    case object ASC extends SortDirection
    case object DESC extends SortDirection
  }
}
package net {
  /** Requests the list of alternative endpoints from server */
  def fetchEndpoints(): Future[Either[Throwable, EndpointsSet]]
  /**
   * Returns ID of the last block in a specified account shard
   * @param address
   */
  def findLastShardBlock(address: String): Future[Either[Throwable, ResultOfFindLastShardBlock]]
  /**
   * Performs DAppServer GraphQL query.
   * @param query
   * @param variables Must be a map with named values thatcan be used in query.
   */
  def query(query: String, variables: Option[Value]): Future[Either[Throwable, ResultOfQuery]]
  /**
   * Queries collection data
   * Queries data that satisfies the `filter` conditions,
   * limits the number of returned records and orders them.
   * The projection fields are limited to `result` fields
   * @param collection
   * @param filter
   * @param result
   * @param order
   * @param limit
   */
  def queryCollection(collection: String, filter: Option[Value], result: String, order: Option[List[OrderBy]], limit: Option[Long]): Future[Either[Throwable, ResultOfQueryCollection]]
  /** Resumes network module to enable network activity */
  def resume(): Future[Either[Throwable, Unit]]
  /**
   * Sets the list of endpoints to use on reinit
   * @param endpoints
   */
  def setEndpoints(endpoints: List[String]): Future[Either[Throwable, Unit]]
  /**
   * Creates a subscription
   * Triggers for each insert/update of data
   * that satisfies the `filter` conditions.
   * The projection fields are limited to `result` fields.
   * @param collection
   * @param filter
   * @param result
   * @param callback
   */
  def subscribeCollection(collection: String, filter: Option[Value], result: String, callback: Request): Future[Either[Throwable, ResultOfSubscribeCollection]]
  /** Suspends network module to stop any network activity */
  def suspend(): Future[Either[Throwable, Unit]]
  /**
   * Cancels a subscription specified by its handle.
   * @param handle Must be closed with `unsubscribe`
   */
  def unsubscribe(handle: Long): Future[Either[Throwable, Unit]]
  /**
   * Returns an object that fulfills the conditions or waits for its appearance
   * Triggers only once.
   * If object that satisfies the `filter` conditions
   * already exists - returns it immediately.
   * If not - waits for insert/update of data within the specified `timeout`,
   * and returns it.
   * The projection fields are limited to `result` fields
   * @param collection
   * @param filter
   * @param result
   * @param timeout
   */
  def waitForCollection(collection: String, filter: Option[Value], result: String, timeout: Option[Long]): Future[Either[Throwable, ResultOfWaitForCollection]]
}
package debot {
  /** [UNSTABLE](UNSTABLE.md) Describes a debot action in a Debot Context. */
  case class DebotAction(description: String, name: String, action_type: Long, to: Long, attributes: String, misc: String)
  sealed trait DebotErrorCode {
    val code: String
  }
  object DebotErrorCode {
    case object DebotExecutionFailed extends DebotErrorCode {
      override val code: String = "803"
    }
    case object DebotFetchFailed extends DebotErrorCode {
      override val code: String = "802"
    }
    case object DebotInvalidHandle extends DebotErrorCode {
      override val code: String = "804"
    }
    case object DebotStartFailed extends DebotErrorCode {
      override val code: String = "801"
    }
  }
  /** [UNSTABLE](UNSTABLE.md) Handle of registered in SDK debot */
  case class DebotHandle(value: BigInt)
  /**
   * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
   * Called by debot engine to communicate with debot browser.
   */
  sealed trait ParamsOfAppDebotBrowser
  object ParamsOfAppDebotBrowser {
    /**
     * Get signing box to sign data.
     * Signing box returned is owned and disposed by debot engine
     */
    case object GetSigningBox extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Input(prompt: String) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class InvokeDebot(debot_addr: String, action: DebotAction) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Log(msg: String) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class ShowAction(action: DebotAction) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Switch(context_id: Long) extends ParamsOfAppDebotBrowser
    /** Notify browser that all context actions are shown. */
    case object SwitchCompleted extends ParamsOfAppDebotBrowser
  }
  /** [UNSTABLE](UNSTABLE.md) Parameters for executing debot action. */
  case class ParamsOfExecute(debot_handle: DebotHandle, action: DebotAction)
  /** [UNSTABLE](UNSTABLE.md) Parameters to fetch debot. */
  case class ParamsOfFetch(address: String)
  /** [UNSTABLE](UNSTABLE.md) Parameters to start debot. */
  case class ParamsOfStart(address: String)
  /** [UNSTABLE](UNSTABLE.md) Structure for storing debot handle returned from `start` and `fetch` functions. */
  case class RegisteredDebot(debot_handle: DebotHandle)
  /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
  sealed trait ResultOfAppDebotBrowser
  object ResultOfAppDebotBrowser {
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    case class GetSigningBox(signing_box: SigningBoxHandle) extends ResultOfAppDebotBrowser
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    case class Input(value: String) extends ResultOfAppDebotBrowser
    /** Result of debot invoking. */
    case object InvokeDebot extends ResultOfAppDebotBrowser
  }
}
package debot {
  /**
   * [UNSTABLE](UNSTABLE.md) Executes debot action.
   * Calls debot engine referenced by debot handle to execute input action.
   * Calls Debot Browser Callbacks if needed.
   *
   * # Remarks
   * Chain of actions can be executed if input action generates a list of subactions.
   * @param debot_handle
   * @param action
   */
  def execute(debot_handle: DebotHandle, action: DebotAction): Future[Either[Throwable, Unit]]
  /**
   * [UNSTABLE](UNSTABLE.md) Fetches debot from blockchain.
   * Downloads debot smart contract (code and data) from blockchain and creates
   * an instance of Debot Engine for it.
   *
   * # Remarks
   * It does not switch debot to context 0. Browser Callbacks are not called.
   * @param address
   * @param app_object
   */
  def fetch(address: String, app_object: ParamsOfAppDebotBrowser => ResultOfAppDebotBrowser): Future[Either[Throwable, RegisteredDebot]]
  /**
   * [UNSTABLE](UNSTABLE.md) Destroys debot handle.
   * Removes handle from Client Context and drops debot engine referenced by that handle.
   * @param debot_handle
   */
  def remove(debot_handle: DebotHandle): Future[Either[Throwable, Unit]]
  /**
   * [UNSTABLE](UNSTABLE.md) Starts an instance of debot.
   * Downloads debot smart contract from blockchain and switches it to
   * context zero.
   * Returns a debot handle which can be used later in `execute` function.
   * This function must be used by Debot Browser to start a dialog with debot.
   * While the function is executing, several Browser Callbacks can be called,
   * since the debot tries to display all actions from the context 0 to the user.
   *
   * # Remarks
   * `start` is equivalent to `fetch` + switch to context 0.
   * @param address
   * @param app_object
   */
  def start(address: String, app_object: ParamsOfAppDebotBrowser => ResultOfAppDebotBrowser): Future[Either[Throwable, RegisteredDebot]]
}