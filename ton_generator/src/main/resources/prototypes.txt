package client {
  case class ClientError(code: Long, message: String, data: com.radiance.Value)
  case class ClientConfig(network: Option[client.NetworkConfig], crypto: Option[client.CryptoConfig], abi: Option[client.AbiConfig])
  case class NetworkConfig(server_address: String, network_retries_count: Option[Int], message_retries_count: Option[Int], message_processing_timeout: Option[Long], wait_for_timeout: Option[Long], out_of_sync_threshold: Option[Long], access_key: Option[String])
  case class CryptoConfig(mnemonic_dictionary: Option[Long], mnemonic_word_count: Option[Long], hdkey_derivation_path: Option[String], hdkey_compliant: Option[Boolean])
  case class AbiConfig(workchain: Option[Int], message_expiration_timeout: Option[Long], message_expiration_timeout_grow_factor: Option[Float])
  case class BuildInfoDependency(name: String, git_commit: String)
  case class ResultOfGetApiReference(api: com.radiance.API)
  case class ResultOfVersion(version: String)
  case class ResultOfBuildInfo(build_number: Long, dependencies: List[client.BuildInfoDependency])
}
/**  Returns detailed information about this build. */
def build_info(): client.ResultOfBuildInfo
/**  Returns Core Library version */
def version(): client.ResultOfVersion
/**  Returns Core Library API reference */
def get_api_reference(): client.ResultOfGetApiReference
package crypto {
  case class SigningBoxHandle(value: BigInt)
  case class ParamsOfFactorize(composite: String)
  case class ResultOfFactorize(factors: List[String])
  case class ParamsOfModularPower(base: String, exponent: String, modulus: String)
  case class ResultOfModularPower(modular_power: String)
  case class ParamsOfTonCrc16(data: String)
  case class ResultOfTonCrc16(crc: Long)
  case class ParamsOfGenerateRandomBytes(length: Long)
  case class ResultOfGenerateRandomBytes(bytes: String)
  case class ParamsOfConvertPublicKeyToTonSafeFormat(public_key: String)
  case class ResultOfConvertPublicKeyToTonSafeFormat(ton_public_key: String)
  case class KeyPair(public: String, secret: String)
  case class ParamsOfSign(unsigned: String, keys: crypto.KeyPair)
  case class ResultOfSign(signed: String, signature: String)
  case class ParamsOfVerifySignature(signed: String, public: String)
  case class ResultOfVerifySignature(unsigned: String)
  case class ParamsOfHash(data: String)
  case class ResultOfHash(hash: String)
  case class ParamsOfScrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long)
  case class ResultOfScrypt(key: String)
  case class ParamsOfNaclSignKeyPairFromSecret(secret: String)
  case class ParamsOfNaclSign(unsigned: String, secret: String)
  case class ResultOfNaclSign(signed: String)
  case class ParamsOfNaclSignOpen(signed: String, public: String)
  case class ResultOfNaclSignOpen(unsigned: String)
  case class ResultOfNaclSignDetached(signature: String)
  case class ParamsOfNaclBoxKeyPairFromSecret(secret: String)
  case class ParamsOfNaclBox(decrypted: String, nonce: String, their_public: String, secret: String)
  case class ResultOfNaclBox(encrypted: String)
  case class ParamsOfNaclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String)
  case class ResultOfNaclBoxOpen(decrypted: String)
  case class ParamsOfNaclSecretBox(decrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSecretBoxOpen(encrypted: String, nonce: String, key: String)
  case class ParamsOfMnemonicWords(dictionary: Option[Long])
  case class ResultOfMnemonicWords(words: String)
  case class ParamsOfMnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicFromRandom(phrase: String)
  case class ParamsOfMnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicFromEntropy(phrase: String)
  case class ParamsOfMnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfMnemonicVerify(valid: Boolean)
  case class ParamsOfMnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfHDKeyXPrvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ResultOfHDKeyXPrvFromMnemonic(xprv: String)
  case class ParamsOfHDKeyDeriveFromXPrv(xprv: String, child_index: Long, hardened: Boolean)
  case class ResultOfHDKeyDeriveFromXPrv(xprv: String)
  case class ParamsOfHDKeyDeriveFromXPrvPath(xprv: String, path: String)
  case class ResultOfHDKeyDeriveFromXPrvPath(xprv: String)
  case class ParamsOfHDKeySecretFromXPrv(xprv: String)
  case class ResultOfHDKeySecretFromXPrv(secret: String)
  case class ParamsOfHDKeyPublicFromXPrv(xprv: String)
  case class ResultOfHDKeyPublicFromXPrv(public: String)
  case class ParamsOfChaCha20(data: String, key: String, nonce: String)
  case class ResultOfChaCha20(data: String)
}
/**
 *  Performs symmetric `chacha20` encryption.@param data  Source data to be encrypted or decrypted. Must be encoded with `base64`.
 * @param key  256-bit key. Must be encoded with `hex`.
 * @param nonce  96-bit nonce. Must be encoded with `hex`.
 */
def chacha20(data: String, key: String, nonce: String): crypto.ResultOfChaCha20
/**  Extracts the public key from the serialized extended private key@param xprv  Serialized extended private key */
def hdkey_public_from_xprv(xprv: String): crypto.ResultOfHDKeyPublicFromXPrv
/**  Extracts the private key from the serialized extended private key@param xprv  Serialized extended private key */
def hdkey_secret_from_xprv(xprv: String): crypto.ResultOfHDKeySecretFromXPrv
/**
 *  Derives the exented private key from the specified key and path@param xprv  Serialized extended private key
 * @param path  Derivation path, for instance "m/44'/396'/0'/0/0"
 */
def hdkey_derive_from_xprv_path(xprv: String, path: String): crypto.ResultOfHDKeyDeriveFromXPrvPath
/**
 *  Returns extended private key derived from the specified extended private key and child index@param xprv  Serialized extended private key
 * @param child_index  Child index (see BIP-0032)
 * @param hardened  Indicates the derivation of hardened/not-hardened key (see BIP-0032)
 */
def hdkey_derive_from_xprv(xprv: String, child_index: Long, hardened: Boolean): crypto.ResultOfHDKeyDeriveFromXPrv
/**
 *  Generates an extended master private key that will be the root for all the derived keys@param phrase  String with seed phrase
 * @param dictionary  Dictionary identifier
 * @param word_count  Mnemonic word count
 */
def hdkey_xprv_from_mnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfHDKeyXPrvFromMnemonic
/**
 * Derives a key pair for signing from the seed phrase
 *  Validates the seed phrase, generates master key and then derives
 *  the key pair from the master key and the specified path@param phrase  Phrase
 * @param path  Derivation path, for instance "m/44'/396'/0'/0/0"
 * @param dictionary  Dictionary identifier
 * @param word_count  Word count
 */
def mnemonic_derive_sign_keys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long]): crypto.KeyPair
/**
 * Validates a mnemonic phrase
 *  The phrase supplied will be checked for word length and validated according to the checksum
 *  specified in BIP0039.@param phrase  Phrase
 * @param dictionary  Dictionary identifier
 * @param word_count  Word count
 */
def mnemonic_verify(phrase: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicVerify
/**
 * Generates mnemonic from the specified entropy
 *  Generates mnemonic from pre-generated entropy@param entropy  Entropy bytes. Hex encoded.
 * @param dictionary  Dictionary identifier
 * @param word_count  Mnemonic word count
 */
def mnemonic_from_entropy(entropy: String, dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicFromEntropy
/**
 *  Generates a random mnemonic from the specified dictionary and word count@param dictionary  Dictionary identifier
 * @param word_count  Mnemonic word count
 */
def mnemonic_from_random(dictionary: Option[Long], word_count: Option[Long]): crypto.ResultOfMnemonicFromRandom
/**  Prints the list of words from the specified dictionary@param dictionary  Dictionary identifier */
def mnemonic_words(dictionary: Option[Long]): crypto.ResultOfMnemonicWords
/**
 *  Decrypts and verifies cipher text using `nonce` and secret `key`.@param encrypted  Data that must be decrypted. Encoded with `base64`.
 * @param nonce  Nonce in `hex`
 * @param key  Public key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_secret_box_open(encrypted: String, nonce: String, key: String): crypto.ResultOfNaclBoxOpen
/**
 *  Encrypt and authenticate message using nonce and secret key.@param decrypted  Data that must be encrypted. Encoded with `base64`.
 * @param nonce  Nonce in `hex`
 * @param key  Secret key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_secret_box(decrypted: String, nonce: String, key: String): crypto.ResultOfNaclBox
/**
 *  Decrypt and verify the cipher text using the recievers secret key, the senders public
 *  key, and the nonce.@param encrypted  Data that must be decrypted. Encoded with `base64`.
 * @param nonce
 * @param their_public  Sender's public key - unprefixed 0-padded to 64 symbols hex string
 * @param secret  Receiver's private key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_box_open(encrypted: String, nonce: String, their_public: String, secret: String): crypto.ResultOfNaclBoxOpen
/**
 *  Public key authenticated encryption
 *
 *  Encrypt and authenticate a message using the senders secret key, the recievers public
 *  key, and a nonce. @param decrypted  Data that must be encrypted encoded in `base64`.
 * @param nonce  Nonce, encoded in `hex`
 * @param their_public  Receiver's public key - unprefixed 0-padded to 64 symbols hex string
 * @param secret  Sender's private key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_box(decrypted: String, nonce: String, their_public: String, secret: String): crypto.ResultOfNaclBox
/**  Generates key pair from a secret key@param secret  Secret key - unprefixed 0-padded to 64 symbols hex string  */
def nacl_box_keypair_from_secret_key(secret: String): crypto.KeyPair
/**
 */
def nacl_box_keypair(): crypto.KeyPair
/**
 * @param unsigned  Data that must be signed encoded in `base64`.
 * @param secret  Signer's secret key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_sign_detached(unsigned: String, secret: String): crypto.ResultOfNaclSignDetached
/**
 * @param signed  Signed data that must be unsigned. Encoded with `base64`.
 * @param public  Signer's public key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_sign_open(signed: String, public: String): crypto.ResultOfNaclSignOpen
/**
 *  Signs data using the signer's secret key.@param unsigned  Data that must be signed encoded in `base64`.
 * @param secret  Signer's secret key - unprefixed 0-padded to 64 symbols hex string
 */
def nacl_sign(unsigned: String, secret: String): crypto.ResultOfNaclSign
/**  Generates a key pair for signing from the secret key@param secret  Secret key - unprefixed 0-padded to 64 symbols hex string  */
def nacl_sign_keypair_from_secret_key(secret: String): crypto.KeyPair
/**
 * Perform `scrypt` encryption
 *  Derives key from `password` and `key` using `scrypt` algorithm.
 *  See [https://en.wikipedia.org/wiki/Scrypt].
 *
 *  # Arguments
 *  - `log_n` - The log2 of the Scrypt parameter `N`
 *  - `r` - The Scrypt parameter `r`
 *  - `p` - The Scrypt parameter `p`
 *  # Conditions
 *  - `log_n` must be less than `64`
 *  - `r` must be greater than `0` and less than or equal to `4294967295`
 *  - `p` must be greater than `0` and less than `4294967295`
 *  # Recommended values sufficient for most use-cases
 *  - `log_n = 15` (`n = 32768`)
 *  - `r = 8`
 *  - `p = 1`@param password  The password bytes to be hashed.
 *  Must be encoded with `base64`.
 * @param salt  Salt bytes that modify the hash to protect against Rainbow table attacks.
 *  Must be encoded with `base64`.
 * @param log_n  CPU/memory cost parameter
 * @param r  The block size parameter, which fine-tunes sequential memory read size and performance.
 * @param p  Parallelization parameter.
 * @param dk_len  Intended output length in octets of the derived key.
 */
def scrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long): crypto.ResultOfScrypt
/**  Calculates SHA512 hash of the specified data.@param data  Input data for hash calculation. Encoded with `base64`. */
def sha512(data: String): crypto.ResultOfHash
/**  Calculates SHA256 hash of the specified data.@param data  Input data for hash calculation. Encoded with `base64`. */
def sha256(data: String): crypto.ResultOfHash
/**
 *  Verifies signed data using the provided public key.
 *  Raises error if verification is failed.@param signed  Signed data that must be verified encoded in `base64`.
 * @param public  Signer's public key - 64 symbols hex string
 */
def verify_signature(signed: String, public: String): crypto.ResultOfVerifySignature
/**
 *  Signs a data using the provided keys.@param unsigned  Data that must be signed encoded in `base64`.
 * @param keys  Sign keys.
 */
def sign(unsigned: String, keys: crypto.KeyPair): crypto.ResultOfSign
/**  Generates random ed25519 key pair. */
def generate_random_sign_keys(): crypto.KeyPair
/**  Converts public key to ton safe_format@param public_key  Public key - 64 symbols hex string */
def convert_public_key_to_ton_safe_format(public_key: String): crypto.ResultOfConvertPublicKeyToTonSafeFormat
/**  Generates random byte array of the specified length and returns it in `base64` format@param length  Size of random byte array. */
def generate_random_bytes(length: Long): crypto.ResultOfGenerateRandomBytes
/**  Calculates CRC16 using TON algorithm.@param data  Input data for CRC calculation. Encoded with `base64`. */
def ton_crc16(data: String): crypto.ResultOfTonCrc16
/**
 * Modular exponentiation
 *  Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`).
 *  See [https://en.wikipedia.org/wiki/Modular_exponentiation]@param base  `base` argument of calculation.
 * @param exponent  `exponent` argument of calculation.
 * @param modulus  `modulus` argument of calculation.
 */
def modular_power(base: String, exponent: String, modulus: String): crypto.ResultOfModularPower
/**
 * Integer factorization
 *  Performs prime factorization – decomposition of a composite number
 *  into a product of smaller prime integers (factors).
 *  See [https://en.wikipedia.org/wiki/Integer_factorization]@param composite  Hexadecimal representation of u64 composite number.
 */
def factorize(composite: String): crypto.ResultOfFactorize
package abi {
  sealed trait Abi
  case class Contract(value: abi.AbiContract) extends Abi
  case class Json(value: String) extends Abi
  case class Handle(value: abi.AbiHandle) extends Abi
  case class Serialized(value: abi.AbiContract) extends Abi
  case class AbiHandle(value: BigInt)
  /**
   *  The ABI function header.
   *
   *  Includes several hidden function parameters that contract
   *  uses for security, message delivery monitoring and replay protection reasons.
   *
   *  The actual set of header fields depends on the contract's ABI.
   *  If a contract's ABI does not include some headers, then they are not filled.
   */
  case class FunctionHeader(expire: Option[Long], time: Option[BigInt], pubkey: Option[String])
  case class CallSet(function_name: String, header: Option[abi.FunctionHeader], input: Option[com.radiance.Value])
  case class DeploySet(tvc: String, workchain_id: Option[Int], initial_data: Option[com.radiance.Value])
  sealed trait Signer
  case class None() extends Signer
  case class External(public_key: String) extends Signer
  case class Keys(keys: crypto.KeyPair) extends Signer
  case class SigningBox(handle: crypto.SigningBoxHandle) extends Signer
  sealed trait MessageBodyType
  /**  Message contains the input of the ABI function. */
  object Input extends MessageBodyType
  /**  Message contains the output of the ABI function. */
  object Output extends MessageBodyType
  /**
   *  Message contains the input of the imported ABI function.
   *
   *  Occurs when contract sends an internal message to other
   *  contract.
   */
  object InternalOutput extends MessageBodyType
  /**  Message contains the input of the ABI event. */
  object Event extends MessageBodyType
  sealed trait StateInitSource
  case class Message(source: abi.MessageSource) extends StateInitSource
  case class StateInit(code: String, data: String, library: Option[String]) extends StateInitSource
  case class Tvc(tvc: String, public_key: Option[String], init_params: Option[abi.StateInitParams]) extends StateInitSource
  case class StateInitParams(abi: abi.Abi, value: com.radiance.Value)
  sealed trait MessageSource
  case class Encoded(message: String, abi: Option[abi.Abi]) extends MessageSource
  case class EncodingParams(value: abi.ParamsOfEncodeMessage) extends MessageSource
  case class AbiParam(name: String, `type`: String, components: Option[List[abi.AbiParam]])
  case class AbiEvent(name: String, inputs: List[abi.AbiParam], id: Option[Option[Long]])
  case class AbiData(key: BigInt, name: String, `type`: String, components: Option[List[abi.AbiParam]])
  case class AbiFunction(name: String, inputs: List[abi.AbiParam], outputs: List[abi.AbiParam], id: Option[Option[Long]])
  case class AbiContract(`ABI version`: Option[Long], abi_version: Option[Long], header: Option[List[String]], functions: Option[List[abi.AbiFunction]], events: Option[List[abi.AbiEvent]], data: Option[List[abi.AbiData]])
  case class ParamsOfEncodeMessageBody(abi: abi.Abi, call_set: abi.CallSet, is_internal: Boolean, signer: abi.Signer, processing_try_index: Option[Long])
  case class ResultOfEncodeMessageBody(body: String, data_to_sign: Option[String])
  case class ParamsOfAttachSignatureToMessageBody(abi: abi.Abi, public_key: String, message: String, signature: String)
  case class ResultOfAttachSignatureToMessageBody(body: String)
  case class ParamsOfEncodeMessage(abi: abi.Abi, address: Option[String], deploy_set: Option[abi.DeploySet], call_set: Option[abi.CallSet], signer: abi.Signer, processing_try_index: Option[Long])
  case class ResultOfEncodeMessage(message: String, data_to_sign: Option[String], address: String, message_id: String)
  case class ParamsOfAttachSignature(abi: abi.Abi, public_key: String, message: String, signature: String)
  case class ResultOfAttachSignature(message: String, message_id: String)
  case class ParamsOfDecodeMessage(abi: abi.Abi, message: String)
  case class DecodedMessageBody(body_type: abi.MessageBodyType, name: String, value: Option[com.radiance.Value], header: Option[abi.FunctionHeader])
  case class ParamsOfDecodeMessageBody(abi: abi.Abi, body: String, is_internal: Boolean)
  case class ParamsOfEncodeAccount(state_init: abi.StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long])
  case class ResultOfEncodeAccount(account: String, id: String)
}
/**
 *  Creates account state BOC
 *
 *  Creates account state provided with one of these sets of data :
 *  1. BOC of code, BOC of data, BOC of library
 *  2. TVC (string in `base64`), keys, init params@param state_init  Source of the account state init.
 * @param balance  Initial balance.
 * @param last_trans_lt  Initial value for the `last_trans_lt`.
 * @param last_paid  Initial value for the `last_paid`.
 */
def encode_account(state_init: abi.StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long]): abi.ResultOfEncodeAccount
/**
 *  Decodes message body using provided body BOC and ABI.@param abi  Contract ABI used to decode.
 * @param body  Message body BOC encoded in `base64`.
 * @param is_internal  True if the body belongs to the internal message.
 */
def decode_message_body(abi: abi.Abi, body: String, is_internal: Boolean): abi.DecodedMessageBody
/**
 *  Decodes message body using provided message BOC and ABI.@param abi  contract ABI
 * @param message  Message BOC
 */
def decode_message(abi: abi.Abi, message: String): abi.DecodedMessageBody
/**
 *  Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`.
 *  Returns signed message encoded in `base64`.@param abi  Contract ABI
 * @param public_key  Public key encoded in `hex`.
 * @param message  Unsigned message BOC encoded in `base64`.
 * @param signature  Signature encoded in `hex`.
 */
def attach_signature(abi: abi.Abi, public_key: String, message: String, signature: String): abi.ResultOfAttachSignature
/**
 *  Encodes an ABI-compatible message
 *
 *  Allows to encode deploy and function call messages,
 *  both signed and unsigned.
 *
 *  Use cases include messages of any possible type:
 *  - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
 *  of initialization);
 *  - deploy without initial function call;
 *  - signed/unsigned + data for signing.
 *
 *  `Signer` defines how the message should or shouldn't be signed:
 *
 *  `Signer::None` creates an unsigned message. This may be needed in case of some public methods,
 *  that do not require authorization by pubkey.
 *
 *  `Signer::External` takes public key and returns `data_to_sign` for later signing.
 *  Use `attach_signature` method with the result signature to get the signed message.
 *
 *  `Signer::Keys` creates a signed message with provided key pair.
 *
 *  [SOON] `Signer::SigningBox` Allows using a special interface to imlepement signing
 *  without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,
 *  when application calls some API to sign data.@param abi  Contract ABI.
 * @param address  Target address the message will be sent to.
 *
 *  Must be specified in case of non-deploy message.
 * @param deploy_set  Deploy parameters.
 *
 *  Must be specified in case of deploy message.
 * @param call_set  Function call parameters.
 *
 *  Must be specified in case of non-deploy message.
 *
 *  In case of deploy message it is optional and contains parameters
 *  of the functions that will to be called upon deploy transaction.
 * @param signer  Signing parameters.
 * @param processing_try_index  Processing try index.
 *
 *  Used in message processing with retries (if contract's ABI includes "expire" header).
 *
 *  Encoder uses the provided try index to calculate message
 *  expiration time. The 1st message expiration time is specified in
 *  Client config.
 *
 *  Expiration timeouts will grow with every retry.
 *  Retry grow factor is set in Client config:
 *  <.....add config parameter with default value here>
 *
 *  Default value is 0.
 */
def encode_message(abi: abi.Abi, address: Option[String], deploy_set: Option[abi.DeploySet], call_set: Option[abi.CallSet], signer: abi.Signer, processing_try_index: Option[Long]): abi.ResultOfEncodeMessage
/**
 * @param abi  Contract ABI
 * @param public_key  Public key. Must be encoded with `hex`.
 * @param message  Unsigned message BOC. Must be encoded with `base64`.
 * @param signature  Signature. Must be encoded with `hex`.
 */
def attach_signature_to_message_body(abi: abi.Abi, public_key: String, message: String, signature: String): abi.ResultOfAttachSignatureToMessageBody
/**
 *  Encodes message body according to ABI function call.@param abi  Contract ABI.
 * @param call_set  Function call parameters.
 *
 *  Must be specified in non deploy message.
 *
 *  In case of deploy message contains parameters of constructor.
 * @param is_internal  True if internal message body must be encoded.
 * @param signer  Signing parameters.
 * @param processing_try_index  Processing try index.
 *
 *  Used in message processing with retries.
 *
 *  Encoder uses the provided try index to calculate message
 *  expiration time.
 *
 *  Expiration timeouts will grow with every retry.
 *
 *  Default value is 0.
 */
def encode_message_body(abi: abi.Abi, call_set: abi.CallSet, is_internal: Boolean, signer: abi.Signer, processing_try_index: Option[Long]): abi.ResultOfEncodeMessageBody
package boc {
  case class ParamsOfParse(boc: String)
  case class ResultOfParse(parsed: com.radiance.Value)
  case class ParamsOfParseShardstate(boc: String, id: String, workchain_id: Int)
  case class ParamsOfGetBlockchainConfig(block_boc: String)
  case class ResultOfGetBlockchainConfig(config_boc: String)
  case class ParamsOfGetBocHash(boc: String)
  case class ResultOfGetBocHash(hash: String)
}
/**  Calculates BOC root hash@param boc  BOC encoded as base64 */
def get_boc_hash(boc: String): boc.ResultOfGetBocHash
/** @param block_boc  Key block BOC encoded as base64 */
def get_blockchain_config(block_boc: String): boc.ResultOfGetBlockchainConfig
/**
 *  Parses shardstate boc into a JSON
 *
 *  JSON structure is compatible with GraphQL API shardstate object@param boc  BOC encoded as base64
 * @param id  Shardstate identificator
 * @param workchain_id  Workchain shardstate belongs to
 */
def parse_shardstate(boc: String, id: String, workchain_id: Int): boc.ResultOfParse
/**
 *  Parses block boc into a JSON
 *
 *  JSON structure is compatible with GraphQL API block object@param boc  BOC encoded as base64
 */
def parse_block(boc: String): boc.ResultOfParse
/**
 *  Parses account boc into a JSON
 *
 *  JSON structure is compatible with GraphQL API account object@param boc  BOC encoded as base64
 */
def parse_account(boc: String): boc.ResultOfParse
/**
 *  Parses transaction boc into a JSON
 *
 *  JSON structure is compatible with GraphQL API transaction object@param boc  BOC encoded as base64
 */
def parse_transaction(boc: String): boc.ResultOfParse
/**
 *  Parses message boc into a JSON
 *
 *  JSON structure is compatible with GraphQL API message object@param boc  BOC encoded as base64
 */
def parse_message(boc: String): boc.ResultOfParse
package processing {
  sealed trait ProcessingEvent
  case class WillFetchFirstBlock() extends ProcessingEvent
  case class FetchFirstBlockFailed(error: client.ClientError) extends ProcessingEvent
  case class WillSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class DidSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class SendFailed(shard_block_id: String, message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class WillFetchNextBlock(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  case class FetchNextBlockFailed(shard_block_id: String, message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class MessageExpired(message_id: String, message: String, error: client.ClientError) extends ProcessingEvent
  case class ResultOfProcessMessage(transaction: com.radiance.Value, out_messages: List[String], decoded: Option[processing.DecodedOutput], fees: tvm.TransactionFees)
  case class DecodedOutput(out_messages: List[Option[abi.DecodedMessageBody]], output: Option[com.radiance.Value])
  case class ParamsOfSendMessage(message: String, abi: Option[abi.Abi], send_events: Boolean)
  case class ResultOfSendMessage(shard_block_id: String)
  case class ParamsOfWaitForTransaction(abi: Option[abi.Abi], message: String, shard_block_id: String, send_events: Boolean)
  case class ParamsOfProcessMessage(message_encode_params: abi.ParamsOfEncodeMessage, send_events: Boolean)
}
/**
 *  Creates message, sends it to the network and monitors its processing.
 *
 *  Creates ABI-compatible message,
 *  sends it to the network and monitors for the result transaction.
 *  Decodes the output messages' bodies.
 *
 *  If contract's ABI includes "expire" header, then
 *  SDK implements retries in case of unsuccessful message delivery within the expiration
 *  timeout: SDK recreates the message, sends it and processes it again.
 *
 *  The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,
 *  `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag
 *  and logged into the supplied callback function.
 *  The retry configuration parameters are defined in config:
 *  <add correct config params here>
 *  pub const DEFAULT_EXPIRATION_RETRIES_LIMIT: i8 = 3; - max number of retries
 *  pub const DEFAULT_EXPIRATION_TIMEOUT: u32 = 40000;  - message expiration timeout in ms.
 *  pub const DEFAULT_....expiration_timeout_grow_factor... = 1.5 - factor that increases the expiration timeout for each retry
 *
 *  If contract's ABI does not include "expire" header
 *  then, if no transaction is found within the network timeout (see config parameter ), exits with error.@param message_encode_params  Message encode parameters.
 * @param send_events  Flag for requesting events sending
 * @param request
 */
def process_message(message_encode_params: abi.ParamsOfEncodeMessage, send_events: Boolean, request: Request): processing.ResultOfProcessMessage
/**
 *  Performs monitoring of the network for the result transaction
 *  of the external inbound message processing.
 *
 *  `send_events` enables intermediate events, such as `WillFetchNextBlock`,
 *  `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation
 *  during message processing.
 *
 *  Note, that presence of the `abi` parameter is critical for ABI
 *  compliant contracts. Message processing uses drastically
 *  different strategy for processing message for contracts which
 *  ABI includes "expire" header.
 *
 *  When the ABI header `expire` is present, the processing uses
 *  `message expiration` strategy:
 *  - The maximum block gen time is set to
 *    `message_expiration_timeout + transaction_wait_timeout`.
 *  - When maximum block gen time is reached, the processing will
 *    be finished with `MessageExpired` error.
 *
 *  When the ABI header `expire` isn't present or `abi` parameter
 *  isn't specified, the processing uses `transaction waiting`
 *  strategy:
 *  - The maximum block gen time is set to
 *    `now() + transaction_wait_timeout`.
 *
 *  - If maximum block gen time is reached and no result transaction is found,
 *  the processing will exit with an error.@param abi  Optional ABI for decoding the transaction result.
 *
 *  If it is specified, then the output messages' bodies will be
 *  decoded according to this ABI.
 *
 *  The `abi_decoded` result field will be filled out.
 * @param message  Message BOC. Encoded with `base64`.
 * @param shard_block_id  The last generated block id of the destination account shard before the message was sent.
 *
 *  You must provide the same value as the `send_message` has returned.
 * @param send_events  Flag that enables/disables intermediate events
 * @param callback
 */
def wait_for_transaction(abi: Option[abi.Abi], message: String, shard_block_id: String, send_events: Boolean, callback: Request): processing.ResultOfProcessMessage
/**
 *  Sends message to the network
 *
 *  Sends message to the network and returns the last generated shard block of the destination account
 *  before the message was sent. It will be required later for message processing.@param message  Message BOC.
 * @param abi  Optional message ABI.
 *
 *  If this parameter is specified and the message has the
 *  `expire` header then expiration time will be checked against
 *  the current time to prevent unnecessary sending of already expired message.
 *
 *  The `message already expired` error will be returned in this
 *  case.
 *
 *  Note, that specifying `abi` for ABI compliant contracts is
 *  strongly recommended, so that proper processing strategy can be
 *  chosen.
 * @param send_events  Flag for requesting events sending
 * @param callback
 */
def send_message(message: String, abi: Option[abi.Abi], send_events: Boolean, callback: Request): processing.ResultOfSendMessage
package utils {
  sealed trait AddressStringFormat
  case class AccountId() extends AddressStringFormat
  case class Hex() extends AddressStringFormat
  case class Base64(url: Boolean, test: Boolean, bounce: Boolean) extends AddressStringFormat
  case class ParamsOfConvertAddress(address: String, output_format: utils.AddressStringFormat)
  case class ResultOfConvertAddress(address: String)
}
/**
 *  Converts address from any TON format to any TON format@param address  Account address in any TON format.
 * @param output_format  Specify the format to convert to.
 */
def convert_address(address: String, output_format: utils.AddressStringFormat): utils.ResultOfConvertAddress
package tvm {
  case class ExecutionOptions(blockchain_config: Option[String], block_time: Option[Long], block_lt: Option[BigInt], transaction_lt: Option[BigInt])
  sealed trait AccountForExecutor
  case class None() extends AccountForExecutor
  case class Uninit() extends AccountForExecutor
  case class Account(boc: String, unlimited_balance: Option[Boolean]) extends AccountForExecutor
  case class TransactionFees(in_msg_fwd_fee: BigInt, storage_fee: BigInt, gas_fee: BigInt, out_msgs_fwd_fee: BigInt, total_account_fees: BigInt, total_output: BigInt)
  case class ParamsOfRunExecutor(message: String, account: tvm.AccountForExecutor, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi], skip_transaction_check: Option[Boolean])
  case class ResultOfRunExecutor(transaction: com.radiance.Value, out_messages: List[String], decoded: Option[processing.DecodedOutput], account: String, fees: tvm.TransactionFees)
  case class ParamsOfRunTvm(message: String, account: String, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi])
  case class ResultOfRunTvm(out_messages: List[String], decoded: Option[processing.DecodedOutput], account: String)
  case class ParamsOfRunGet(account: String, function_name: String, input: Option[com.radiance.Value], execution_options: Option[tvm.ExecutionOptions])
  case class ResultOfRunGet(output: com.radiance.Value)
}
/**
 *  Executes getmethod and returns data from TVM stack@param account  Account BOC in `base64`
 * @param function_name  Function name
 * @param input  Input parameters
 * @param execution_options
 */
def run_get(account: String, function_name: String, input: Option[com.radiance.Value], execution_options: Option[tvm.ExecutionOptions]): tvm.ResultOfRunGet
/**
 * @param message  Input message BOC. Must be encoded as base64.
 * @param account  Account BOC. Must be encoded as base64.
 * @param execution_options  Execution options.
 * @param abi  Contract ABI for dedcoding output messages
 */
def run_tvm(message: String, account: String, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi]): tvm.ResultOfRunTvm
/**
 * @param message  Input message BOC. Must be encoded as base64.
 * @param account  Account to run on executor
 * @param execution_options  Execution options.
 * @param abi  Contract ABI for decoding output messages
 * @param skip_transaction_check  Skip transaction check flag
 */
def run_executor(message: String, account: tvm.AccountForExecutor, execution_options: Option[tvm.ExecutionOptions], abi: Option[abi.Abi], skip_transaction_check: Option[Boolean]): tvm.ResultOfRunExecutor
package net {
  case class OrderBy(path: String, direction: net.SortDirection)
  sealed trait SortDirection
  object ASC extends SortDirection
  object DESC extends SortDirection
  case class ParamsOfQueryCollection(collection: String, filter: Option[com.radiance.Value], result: String, order: Option[List[net.OrderBy]], limit: Option[Long])
  case class ResultOfQueryCollection(result: List[com.radiance.Value])
  case class ParamsOfWaitForCollection(collection: String, filter: Option[com.radiance.Value], result: String, timeout: Option[Long])
  case class ResultOfWaitForCollection(result: com.radiance.Value)
  case class ResultOfSubscribeCollection(handle: Long)
  object unit
  case class ParamsOfSubscribeCollection(collection: String, filter: Option[com.radiance.Value], result: String)
}
/**
 *  Creates a subscription
 *
 *  Triggers for each insert/update of data
 *  that satisfies the `filter` conditions.
 *  The projection fields are limited to `result` fields.@param collection  Collection name (accounts, blocks, transactions, messages, block_signatures)
 * @param filter  Collection filter
 * @param result  Projection (result) string
 * @param callback
 */
def subscribe_collection(collection: String, filter: Option[com.radiance.Value], result: String, callback: Request): net.ResultOfSubscribeCollection
/**
 *  Cancels a subscription
 *
 *  Cancels a subscription specified by its handle.@param handle  Subscription handle. Must be closed with `unsubscribe`
 */
def unsubscribe(handle: Long): Unit
/**
 *  Returns an object that fulfills the conditions or waits for its appearance
 *
 *  Triggers only once.
 *  If object that satisfies the `filter` conditions
 *  already exists - returns it immediately.
 *  If not - waits for insert/update of data within the specified `timeout`,
 *  and returns it.
 *  The projection fields are limited to `result` fields@param collection  Collection name (accounts, blocks, transactions, messages, block_signatures)
 * @param filter  Collection filter
 * @param result  Projection (result) string
 * @param timeout  Query timeout
 */
def wait_for_collection(collection: String, filter: Option[com.radiance.Value], result: String, timeout: Option[Long]): net.ResultOfWaitForCollection
/**
 *  Queries collection data
 *
 *  Queries data that satisfies the `filter` conditions,
 *  limits the number of returned records and orders them.
 *  The projection fields are limited to `result` fields@param collection  Collection name (accounts, blocks, transactions, messages, block_signatures)
 * @param filter  Collection filter
 * @param result  Projection (result) string
 * @param order  Sorting order
 * @param limit  Number of documents to return
 */
def query_collection(collection: String, filter: Option[com.radiance.Value], result: String, order: Option[List[net.OrderBy]], limit: Option[Long]): net.ResultOfQueryCollection