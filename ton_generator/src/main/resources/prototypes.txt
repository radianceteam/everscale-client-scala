package client {
  case class AbiConfig(workchain: Option[Int], message_expiration_timeout: Option[Long], message_expiration_timeout_grow_factor: Option[Float])
  object AppRequestResultADT {
    sealed trait AppRequestResult
    case class Error(text: String) extends AppRequestResult
    case class Ok(result: Value) extends AppRequestResult
  }
  case class BocConfig(cache_max_size: Option[Long])
  case class BuildInfoDependency(name: String, git_commit: String)
  case class ClientConfig(network: Option[NetworkConfig], crypto: Option[CryptoConfig], abi: Option[AbiConfig], boc: Option[BocConfig])
  case class ClientError(code: Long, message: String, data: Value)
  object ClientErrorCodeEnum {
    sealed trait ClientErrorCode {
      val code: String
    }
    case object AppRequestError extends ClientErrorCode {
      override val code: String = "26"
    }
    case object CallbackNotRegistered extends ClientErrorCode {
      override val code: String = "13"
    }
    case object CallbackParamsCantBeConvertedToJson extends ClientErrorCode {
      override val code: String = "5"
    }
    case object CanNotParseNumber extends ClientErrorCode {
      override val code: String = "32"
    }
    case object CanNotParseRequestResult extends ClientErrorCode {
      override val code: String = "30"
    }
    case object CanNotReceiveRequestResult extends ClientErrorCode {
      override val code: String = "29"
    }
    case object CanNotSendRequestResult extends ClientErrorCode {
      override val code: String = "28"
    }
    case object CannotConvertJsValueToJson extends ClientErrorCode {
      override val code: String = "20"
    }
    case object CannotCreateRuntime extends ClientErrorCode {
      override val code: String = "16"
    }
    case object CannotReceiveSpawnedResult extends ClientErrorCode {
      override val code: String = "21"
    }
    case object CannotSerializeError extends ClientErrorCode {
      override val code: String = "19"
    }
    case object CannotSerializeResult extends ClientErrorCode {
      override val code: String = "18"
    }
    case object ContractsAddressConversionFailed extends ClientErrorCode {
      override val code: String = "24"
    }
    case object HttpClientCreateError extends ClientErrorCode {
      override val code: String = "9"
    }
    case object HttpRequestCreateError extends ClientErrorCode {
      override val code: String = "10"
    }
    case object HttpRequestParseError extends ClientErrorCode {
      override val code: String = "12"
    }
    case object HttpRequestSendError extends ClientErrorCode {
      override val code: String = "11"
    }
    case object InternalError extends ClientErrorCode {
      override val code: String = "33"
    }
    case object InvalidAddress extends ClientErrorCode {
      override val code: String = "4"
    }
    case object InvalidBase64 extends ClientErrorCode {
      override val code: String = "3"
    }
    case object InvalidConfig extends ClientErrorCode {
      override val code: String = "15"
    }
    case object InvalidContextHandle extends ClientErrorCode {
      override val code: String = "17"
    }
    case object InvalidHandle extends ClientErrorCode {
      override val code: String = "34"
    }
    case object InvalidHex extends ClientErrorCode {
      override val code: String = "2"
    }
    case object InvalidParams extends ClientErrorCode {
      override val code: String = "23"
    }
    case object NetModuleNotInit extends ClientErrorCode {
      override val code: String = "14"
    }
    case object NoSuchRequest extends ClientErrorCode {
      override val code: String = "27"
    }
    case object NotImplemented extends ClientErrorCode {
      override val code: String = "1"
    }
    case object SetTimerError extends ClientErrorCode {
      override val code: String = "22"
    }
    case object UnexpectedCallbackResponse extends ClientErrorCode {
      override val code: String = "31"
    }
    case object UnknownFunction extends ClientErrorCode {
      override val code: String = "25"
    }
    case object WebsocketConnectError extends ClientErrorCode {
      override val code: String = "6"
    }
    case object WebsocketReceiveError extends ClientErrorCode {
      override val code: String = "7"
    }
    case object WebsocketSendError extends ClientErrorCode {
      override val code: String = "8"
    }
  }
  /** Crypto config. */
  case class CryptoConfig(mnemonic_dictionary: Option[Long], mnemonic_word_count: Option[Long], hdkey_derivation_path: Option[String])
  case class NetworkConfig(server_address: Option[String], endpoints: Option[List[String]], network_retries_count: Option[Int], max_reconnect_timeout: Option[Long], reconnect_timeout: Option[Long], message_retries_count: Option[Int], message_processing_timeout: Option[Long], wait_for_timeout: Option[Long], out_of_sync_threshold: Option[Long], sending_endpoint_count: Option[Long], latency_detection_interval: Option[Long], max_latency: Option[Long], query_timeout: Option[Long], access_key: Option[String])
  case class ParamsOfAppRequest(app_request_id: Long, request_data: Value)
  case class ParamsOfResolveAppRequest(app_request_id: Long, result: AppRequestResult)
  case class ResultOfBuildInfo(build_number: Long, dependencies: List[BuildInfoDependency])
  case class ResultOfGetApiReference(api: API)
  case class ResultOfVersion(version: String)
}
package client {
  /** Returns detailed information about this build. */
  def buildInfo(): Future[Either[Throwable, ResultOfBuildInfo]]
  /** Returns Core Library API reference */
  def getApiReference(): Future[Either[Throwable, ResultOfGetApiReference]]
  /**
   * Resolves application request processing result
   * @param app_request_id app_request_id
   * @param result result
   */
  def resolveAppRequest(app_request_id: Long, result: AppRequestResult): Future[Either[Throwable, Unit]]
  /** Returns Core Library version */
  def version(): Future[Either[Throwable, ResultOfVersion]]
}
package crypto {
  case class AesInfo(mode: CipherMode, iv: Option[String])
  case class AesParams(mode: CipherMode, key: String, iv: Option[String])
  object CipherModeEnum {
    sealed trait CipherMode
    case object CBC extends CipherMode
    case object CFB extends CipherMode
    case object CTR extends CipherMode
    case object ECB extends CipherMode
    case object OFB extends CipherMode
  }
  object CryptoErrorCodeEnum {
    sealed trait CryptoErrorCode {
      val code: String
    }
    case object Bip32InvalidDerivePath extends CryptoErrorCode {
      override val code: String = "116"
    }
    case object Bip32InvalidKey extends CryptoErrorCode {
      override val code: String = "115"
    }
    case object Bip39InvalidDictionary extends CryptoErrorCode {
      override val code: String = "117"
    }
    case object Bip39InvalidEntropy extends CryptoErrorCode {
      override val code: String = "113"
    }
    case object Bip39InvalidPhrase extends CryptoErrorCode {
      override val code: String = "114"
    }
    case object Bip39InvalidWordCount extends CryptoErrorCode {
      override val code: String = "118"
    }
    case object CannotCreateCipher extends CryptoErrorCode {
      override val code: String = "126"
    }
    case object DecryptDataError extends CryptoErrorCode {
      override val code: String = "128"
    }
    case object EncryptDataError extends CryptoErrorCode {
      override val code: String = "127"
    }
    case object EncryptionBoxNotRegistered extends CryptoErrorCode {
      override val code: String = "123"
    }
    case object InvalidBigInt extends CryptoErrorCode {
      override val code: String = "107"
    }
    case object InvalidFactorizeChallenge extends CryptoErrorCode {
      override val code: String = "106"
    }
    case object InvalidIvSize extends CryptoErrorCode {
      override val code: String = "124"
    }
    case object InvalidKey extends CryptoErrorCode {
      override val code: String = "102"
    }
    case object InvalidKeySize extends CryptoErrorCode {
      override val code: String = "109"
    }
    case object InvalidPublicKey extends CryptoErrorCode {
      override val code: String = "100"
    }
    case object InvalidSecretKey extends CryptoErrorCode {
      override val code: String = "101"
    }
    case object InvalidSignature extends CryptoErrorCode {
      override val code: String = "122"
    }
    case object IvRequired extends CryptoErrorCode {
      override val code: String = "129"
    }
    case object MnemonicFromEntropyFailed extends CryptoErrorCode {
      override val code: String = "120"
    }
    case object MnemonicGenerationFailed extends CryptoErrorCode {
      override val code: String = "119"
    }
    case object NaclBoxFailed extends CryptoErrorCode {
      override val code: String = "111"
    }
    case object NaclSecretBoxFailed extends CryptoErrorCode {
      override val code: String = "110"
    }
    case object NaclSignFailed extends CryptoErrorCode {
      override val code: String = "112"
    }
    case object ScryptFailed extends CryptoErrorCode {
      override val code: String = "108"
    }
    case object SigningBoxNotRegistered extends CryptoErrorCode {
      override val code: String = "121"
    }
    case object UnsupportedCipherMode extends CryptoErrorCode {
      override val code: String = "125"
    }
  }
  object EncryptionAlgorithmADT {
    sealed trait EncryptionAlgorithm
    case class AES(value: AesParams) extends EncryptionAlgorithm
  }
  case class EncryptionBoxHandle(value: BigInt) extends AnyVal
  /** Encryption box information */
  case class EncryptionBoxInfo(hdpath: Option[String], algorithm: Option[String], options: Option[Value], public: Option[Value])
  case class KeyPair(public: String, secret: String)
  object ParamsOfAppEncryptionBoxADT {
    /** Encryption box callbacks. */
    sealed trait ParamsOfAppEncryptionBox
    /** Encryption box callbacks. */
    case class Decrypt(data: String) extends ParamsOfAppEncryptionBox
    /** Encryption box callbacks. */
    case class Encrypt(data: String) extends ParamsOfAppEncryptionBox
    /** Get encryption box info */
    case object GetInfo extends ParamsOfAppEncryptionBox
  }
  object ParamsOfAppSigningBoxADT {
    /** Signing box callbacks. */
    sealed trait ParamsOfAppSigningBox
    /** Get signing box public key */
    case object GetPublicKey extends ParamsOfAppSigningBox
    /** Signing box callbacks. */
    case class Sign(unsigned: String) extends ParamsOfAppSigningBox
  }
  case class ParamsOfChaCha20(data: String, key: String, nonce: String)
  case class ParamsOfConvertPublicKeyToTonSafeFormat(public_key: String)
  case class ParamsOfCreateEncryptionBox(algorithm: EncryptionAlgorithm)
  case class ParamsOfEncryptionBoxDecrypt(encryption_box: EncryptionBoxHandle, data: String)
  case class ParamsOfEncryptionBoxEncrypt(encryption_box: EncryptionBoxHandle, data: String)
  case class ParamsOfEncryptionBoxGetInfo(encryption_box: EncryptionBoxHandle)
  case class ParamsOfFactorize(composite: String)
  case class ParamsOfGenerateRandomBytes(length: Long)
  case class ParamsOfHDKeyDeriveFromXPrv(xprv: String, child_index: Long, hardened: Boolean)
  case class ParamsOfHDKeyDeriveFromXPrvPath(xprv: String, path: String)
  case class ParamsOfHDKeyPublicFromXPrv(xprv: String)
  case class ParamsOfHDKeySecretFromXPrv(xprv: String)
  case class ParamsOfHDKeyXPrvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfHash(data: String)
  case class ParamsOfMnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long])
  case class ParamsOfMnemonicWords(dictionary: Option[Long])
  case class ParamsOfModularPower(base: String, exponent: String, modulus: String)
  case class ParamsOfNaclBox(decrypted: String, nonce: String, their_public: String, secret: String)
  case class ParamsOfNaclBoxKeyPairFromSecret(secret: String)
  case class ParamsOfNaclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String)
  case class ParamsOfNaclSecretBox(decrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSecretBoxOpen(encrypted: String, nonce: String, key: String)
  case class ParamsOfNaclSign(unsigned: String, secret: String)
  case class ParamsOfNaclSignDetachedVerify(unsigned: String, signature: String, public: String)
  case class ParamsOfNaclSignKeyPairFromSecret(secret: String)
  case class ParamsOfNaclSignOpen(signed: String, public: String)
  case class ParamsOfScrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long)
  case class ParamsOfSign(unsigned: String, keys: KeyPair)
  case class ParamsOfSigningBoxSign(signing_box: SigningBoxHandle, unsigned: String)
  case class ParamsOfTonCrc16(data: String)
  case class ParamsOfVerifySignature(signed: String, public: String)
  case class RegisteredEncryptionBox(handle: EncryptionBoxHandle)
  case class RegisteredSigningBox(handle: SigningBoxHandle)
  object ResultOfAppEncryptionBoxADT {
    /** Returning values from signing box callbacks. */
    sealed trait ResultOfAppEncryptionBox
    /** Returning values from signing box callbacks. */
    case class Decrypt(data: String) extends ResultOfAppEncryptionBox
    /** Returning values from signing box callbacks. */
    case class Encrypt(data: String) extends ResultOfAppEncryptionBox
    /** Returning values from signing box callbacks. */
    case class GetInfo(info: EncryptionBoxInfo) extends ResultOfAppEncryptionBox
  }
  object ResultOfAppSigningBoxADT {
    /** Returning values from signing box callbacks. */
    sealed trait ResultOfAppSigningBox
    /** Returning values from signing box callbacks. */
    case class GetPublicKey(public_key: String) extends ResultOfAppSigningBox
    /** Returning values from signing box callbacks. */
    case class Sign(signature: String) extends ResultOfAppSigningBox
  }
  case class ResultOfChaCha20(data: String)
  case class ResultOfConvertPublicKeyToTonSafeFormat(ton_public_key: String)
  case class ResultOfEncryptionBoxDecrypt(data: String)
  case class ResultOfEncryptionBoxEncrypt(data: String)
  case class ResultOfEncryptionBoxGetInfo(info: EncryptionBoxInfo)
  case class ResultOfFactorize(factors: List[String])
  case class ResultOfGenerateRandomBytes(bytes: String)
  case class ResultOfHDKeyDeriveFromXPrv(xprv: String)
  case class ResultOfHDKeyDeriveFromXPrvPath(xprv: String)
  case class ResultOfHDKeyPublicFromXPrv(public: String)
  case class ResultOfHDKeySecretFromXPrv(secret: String)
  case class ResultOfHDKeyXPrvFromMnemonic(xprv: String)
  case class ResultOfHash(hash: String)
  case class ResultOfMnemonicFromEntropy(phrase: String)
  case class ResultOfMnemonicFromRandom(phrase: String)
  case class ResultOfMnemonicVerify(valid: Boolean)
  case class ResultOfMnemonicWords(words: String)
  case class ResultOfModularPower(modular_power: String)
  case class ResultOfNaclBox(encrypted: String)
  case class ResultOfNaclBoxOpen(decrypted: String)
  case class ResultOfNaclSign(signed: String)
  case class ResultOfNaclSignDetached(signature: String)
  case class ResultOfNaclSignDetachedVerify(succeeded: Boolean)
  case class ResultOfNaclSignOpen(unsigned: String)
  case class ResultOfScrypt(key: String)
  case class ResultOfSign(signed: String, signature: String)
  case class ResultOfSigningBoxGetPublicKey(pubkey: String)
  case class ResultOfSigningBoxSign(signature: String)
  case class ResultOfTonCrc16(crc: Long)
  case class ResultOfVerifySignature(unsigned: String)
  case class SigningBoxHandle(value: BigInt) extends AnyVal
}
package crypto {
  /**
   * Performs symmetric `chacha20` encryption.
   * @param data Must be encoded with `base64`.
   * @param key Must be encoded with `hex`.
   * @param nonce Must be encoded with `hex`.
   */
  def chacha20(data: String, key: String, nonce: String): Future[Either[Throwable, ResultOfChaCha20]]
  /**
   * Converts public key to ton safe_format
   * @param public_key public_key
   */
  def convertPublicKeyToTonSafeFormat(public_key: String): Future[Either[Throwable, ResultOfConvertPublicKeyToTonSafeFormat]]
  /**
   * Creates encryption box with specified algorithm
   * @param algorithm algorithm
   */
  def createEncryptionBox(algorithm: EncryptionAlgorithm): Future[Either[Throwable, RegisteredEncryptionBox]]
  /**
   * Decrypts data using given encryption box Note.
   * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after
   * decryption to retrieve the original data from decrypted data.
   * @param encryption_box encryption_box
   * @param data data
   */
  def encryptionBoxDecrypt(encryption_box: EncryptionBoxHandle, data: String): Future[Either[Throwable, ResultOfEncryptionBoxDecrypt]]
  /**
   * Encrypts data using given encryption box Note.
   * Block cipher algorithms pad data to cipher block size so encrypted data can be longer then original data. Client should store the original data size after encryption and use it after
   * decryption to retrieve the original data from decrypted data.
   * @param encryption_box encryption_box
   * @param data data
   */
  def encryptionBoxEncrypt(encryption_box: EncryptionBoxHandle, data: String): Future[Either[Throwable, ResultOfEncryptionBoxEncrypt]]
  /**
   * Queries info from the given encryption box
   * @param encryption_box encryption_box
   */
  def encryptionBoxGetInfo(encryption_box: EncryptionBoxHandle): Future[Either[Throwable, ResultOfEncryptionBoxGetInfo]]
  /**
   * Integer factorization
   * Performs prime factorization – decomposition of a composite number
   * into a product of smaller prime integers (factors).
   * See [https://en.wikipedia.org/wiki/Integer_factorization]
   * @param composite composite
   */
  def factorize(composite: String): Future[Either[Throwable, ResultOfFactorize]]
  /**
   * Generates random byte array of the specified length and returns it in `base64` format
   * @param length length
   */
  def generateRandomBytes(length: Long): Future[Either[Throwable, ResultOfGenerateRandomBytes]]
  /** Generates random ed25519 key pair. */
  def generateRandomSignKeys(): Future[Either[Throwable, KeyPair]]
  /**
   * Creates a default signing box implementation.
   * @param public public
   * @param secret secret
   */
  def getSigningBox(public: String, secret: String): Future[Either[Throwable, RegisteredSigningBox]]
  /**
   * Returns extended private key derived from the specified extended private key and child index
   * @param xprv xprv
   * @param child_index child_index
   * @param hardened hardened
   */
  def hdkeyDeriveFromXprv(xprv: String, child_index: Long, hardened: Boolean): Future[Either[Throwable, ResultOfHDKeyDeriveFromXPrv]]
  /**
   * Derives the extended private key from the specified key and path
   * @param xprv xprv
   * @param path path
   */
  def hdkeyDeriveFromXprvPath(xprv: String, path: String): Future[Either[Throwable, ResultOfHDKeyDeriveFromXPrvPath]]
  /**
   * Extracts the public key from the serialized extended private key
   * @param xprv xprv
   */
  def hdkeyPublicFromXprv(xprv: String): Future[Either[Throwable, ResultOfHDKeyPublicFromXPrv]]
  /**
   * Extracts the private key from the serialized extended private key
   * @param xprv xprv
   */
  def hdkeySecretFromXprv(xprv: String): Future[Either[Throwable, ResultOfHDKeySecretFromXPrv]]
  /**
   * Generates an extended master private key that will be the root for all the derived keys
   * @param phrase phrase
   * @param dictionary dictionary
   * @param word_count word_count
   */
  def hdkeyXprvFromMnemonic(phrase: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfHDKeyXPrvFromMnemonic]]
  /**
   * Derives a key pair for signing from the seed phrase
   * Validates the seed phrase, generates master key and then derives
   * the key pair from the master key and the specified path
   * @param phrase phrase
   * @param path path
   * @param dictionary dictionary
   * @param word_count word_count
   */
  def mnemonicDeriveSignKeys(phrase: String, path: Option[String], dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, KeyPair]]
  /**
   * Generates mnemonic from pre-generated entropy
   * @param entropy Hex encoded.
   * @param dictionary dictionary
   * @param word_count word_count
   */
  def mnemonicFromEntropy(entropy: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicFromEntropy]]
  /**
   * Generates a random mnemonic from the specified dictionary and word count
   * @param dictionary dictionary
   * @param word_count word_count
   */
  def mnemonicFromRandom(dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicFromRandom]]
  /**
   * Validates a mnemonic phrase
   * The phrase supplied will be checked for word length and validated according to the checksum
   * specified in BIP0039.
   * @param phrase phrase
   * @param dictionary dictionary
   * @param word_count word_count
   */
  def mnemonicVerify(phrase: String, dictionary: Option[Long], word_count: Option[Long]): Future[Either[Throwable, ResultOfMnemonicVerify]]
  /**
   * Prints the list of words from the specified dictionary
   * @param dictionary dictionary
   */
  def mnemonicWords(dictionary: Option[Long]): Future[Either[Throwable, ResultOfMnemonicWords]]
  /**
   * Modular exponentiation
   * Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`).
   * See [https://en.wikipedia.org/wiki/Modular_exponentiation]
   * @param base base
   * @param exponent exponent
   * @param modulus modulus
   */
  def modularPower(base: String, exponent: String, modulus: String): Future[Either[Throwable, ResultOfModularPower]]
  /**
   * Public key authenticated encryption
   * Encrypt and authenticate a message using the senders secret key, the receivers public
   * key, and a nonce.
   * @param decrypted decrypted
   * @param nonce nonce
   * @param their_public their_public
   * @param secret secret
   */
  def naclBox(decrypted: String, nonce: String, their_public: String, secret: String): Future[Either[Throwable, ResultOfNaclBox]]
  /** Generates a random NaCl key pair */
  def naclBoxKeypair(): Future[Either[Throwable, KeyPair]]
  /**
   * Generates key pair from a secret key
   * @param secret secret
   */
  def naclBoxKeypairFromSecretKey(secret: String): Future[Either[Throwable, KeyPair]]
  /**
   * Decrypt and verify the cipher text using the receivers secret key, the senders public key, and the nonce.
   * @param encrypted Encoded with `base64`.
   * @param nonce nonce
   * @param their_public their_public
   * @param secret secret
   */
  def naclBoxOpen(encrypted: String, nonce: String, their_public: String, secret: String): Future[Either[Throwable, ResultOfNaclBoxOpen]]
  /**
   * Encrypt and authenticate message using nonce and secret key.
   * @param decrypted Encoded with `base64`.
   * @param nonce nonce
   * @param key key
   */
  def naclSecretBox(decrypted: String, nonce: String, key: String): Future[Either[Throwable, ResultOfNaclBox]]
  /**
   * Decrypts and verifies cipher text using `nonce` and secret `key`.
   * @param encrypted Encoded with `base64`.
   * @param nonce nonce
   * @param key key
   */
  def naclSecretBoxOpen(encrypted: String, nonce: String, key: String): Future[Either[Throwable, ResultOfNaclBoxOpen]]
  /**
   * Signs data using the signer's secret key.
   * @param unsigned unsigned
   * @param secret secret
   */
  def naclSign(unsigned: String, secret: String): Future[Either[Throwable, ResultOfNaclSign]]
  /**
   * Signs the message using the secret key and returns a signature.
   * Signs the message `unsigned` using the secret key `secret`
   * and returns a signature `signature`.
   * @param unsigned unsigned
   * @param secret secret
   */
  def naclSignDetached(unsigned: String, secret: String): Future[Either[Throwable, ResultOfNaclSignDetached]]
  /**
   * Verifies the signature with public key and `unsigned` data.
   * @param unsigned Encoded with `base64`.
   * @param signature Encoded with `hex`.
   * @param public public
   */
  def naclSignDetachedVerify(unsigned: String, signature: String, public: String): Future[Either[Throwable, ResultOfNaclSignDetachedVerify]]
  /**
   * Generates a key pair for signing from the secret key
   * **NOTE:** In the result the secret key is actually the concatenation
   * of secret and public keys (128 symbols hex string) by design of [NaCL](http://nacl.cr.yp.to/sign.html).
   * See also [the stackexchange question](https://crypto.stackexchange.com/questions/54353/).
   * @param secret secret
   */
  def naclSignKeypairFromSecretKey(secret: String): Future[Either[Throwable, KeyPair]]
  /**
   * Verifies the signature and returns the unsigned message
   * Verifies the signature in `signed` using the signer's public key `public`
   * and returns the message `unsigned`.
   *
   * If the signature fails verification, crypto_sign_open raises an exception.
   * @param signed Encoded with `base64`.
   * @param public public
   */
  def naclSignOpen(signed: String, public: String): Future[Either[Throwable, ResultOfNaclSignOpen]]
  /**
   * Register an application implemented encryption box.
   * @param app_object app_object
   */
  def registerEncryptionBox(app_object: ParamsOfAppEncryptionBox => ResultOfAppEncryptionBox): Future[Either[Throwable, RegisteredEncryptionBox]]
  /**
   * Register an application implemented signing box.
   * @param app_object app_object
   */
  def registerSigningBox(app_object: ParamsOfAppSigningBox => ResultOfAppSigningBox): Future[Either[Throwable, RegisteredSigningBox]]
  /**
   * Removes encryption box from SDK
   * @param handle handle
   */
  def removeEncryptionBox(handle: EncryptionBoxHandle): Future[Either[Throwable, Unit]]
  /**
   * Removes signing box from SDK.
   * @param handle handle
   */
  def removeSigningBox(handle: SigningBoxHandle): Future[Either[Throwable, Unit]]
  /**
   * Perform `scrypt` encryption
   * Derives key from `password` and `key` using `scrypt` algorithm.
   * See [https://en.wikipedia.org/wiki/Scrypt].
   *
   * # Arguments
   * - `log_n` - The log2 of the Scrypt parameter `N`
   * - `r` - The Scrypt parameter `r`
   * - `p` - The Scrypt parameter `p`
   * # Conditions
   * - `log_n` must be less than `64`
   * - `r` must be greater than `0` and less than or equal to `4294967295`
   * - `p` must be greater than `0` and less than `4294967295`
   * # Recommended values sufficient for most use-cases
   * - `log_n = 15` (`n = 32768`)
   * - `r = 8`
   * - `p = 1`
   * @param password password
   * @param salt salt
   * @param log_n log_n
   * @param r r
   * @param p p
   * @param dk_len dk_len
   */
  def scrypt(password: String, salt: String, log_n: Long, r: Long, p: Long, dk_len: Long): Future[Either[Throwable, ResultOfScrypt]]
  /**
   * Calculates SHA256 hash of the specified data.
   * @param data Encoded with `base64`.
   */
  def sha256(data: String): Future[Either[Throwable, ResultOfHash]]
  /**
   * Calculates SHA512 hash of the specified data.
   * @param data Encoded with `base64`.
   */
  def sha512(data: String): Future[Either[Throwable, ResultOfHash]]
  /**
   * Signs a data using the provided keys.
   * @param unsigned unsigned
   * @param keys keys
   */
  def sign(unsigned: String, keys: KeyPair): Future[Either[Throwable, ResultOfSign]]
  /**
   * Returns public key of signing key pair.
   * @param handle handle
   */
  def signingBoxGetPublicKey(handle: SigningBoxHandle): Future[Either[Throwable, ResultOfSigningBoxGetPublicKey]]
  /**
   * Returns signed user data.
   * @param signing_box signing_box
   * @param unsigned Must be encoded with `base64`.
   */
  def signingBoxSign(signing_box: SigningBoxHandle, unsigned: String): Future[Either[Throwable, ResultOfSigningBoxSign]]
  /**
   * Calculates CRC16 using TON algorithm.
   * @param data Encoded with `base64`.
   */
  def tonCrc16(data: String): Future[Either[Throwable, ResultOfTonCrc16]]
  /**
   * Verifies signed data using the provided public key. Raises error if verification is failed.
   * @param signed signed
   * @param public public
   */
  def verifySignature(signed: String, public: String): Future[Either[Throwable, ResultOfVerifySignature]]
}
package abi {
  object AbiADT {
    sealed trait Abi
    case class Contract(value: AbiContract) extends Abi
    case class Handle(value: AbiHandle) extends Abi
    case class Json(value: String) extends Abi
    case class Serialized(value: AbiContract) extends Abi
  }
  case class AbiContract(`ABI version`: Option[Long], abi_version: Option[Long], version: Option[Option[String]], header: Option[List[String]], functions: Option[List[AbiFunction]], events: Option[List[AbiEvent]], data: Option[List[AbiData]], fields: Option[List[AbiParam]])
  case class AbiData(key: Long, name: String, `type`: String, components: Option[List[AbiParam]])
  object AbiErrorCodeEnum {
    sealed trait AbiErrorCode {
      val code: String
    }
    case object AttachSignatureFailed extends AbiErrorCode {
      override val code: String = "307"
    }
    case object EncodeDeployMessageFailed extends AbiErrorCode {
      override val code: String = "305"
    }
    case object EncodeInitialDataFailed extends AbiErrorCode {
      override val code: String = "314"
    }
    case object EncodeRunMessageFailed extends AbiErrorCode {
      override val code: String = "306"
    }
    case object InvalidAbi extends AbiErrorCode {
      override val code: String = "311"
    }
    case object InvalidData extends AbiErrorCode {
      override val code: String = "313"
    }
    case object InvalidFunctionId extends AbiErrorCode {
      override val code: String = "312"
    }
    case object InvalidJson extends AbiErrorCode {
      override val code: String = "303"
    }
    case object InvalidMessage extends AbiErrorCode {
      override val code: String = "304"
    }
    case object InvalidSigner extends AbiErrorCode {
      override val code: String = "310"
    }
    case object InvalidTvcImage extends AbiErrorCode {
      override val code: String = "308"
    }
    case object RequiredAddressMissingForEncodeMessage extends AbiErrorCode {
      override val code: String = "301"
    }
    case object RequiredCallSetMissingForEncodeMessage extends AbiErrorCode {
      override val code: String = "302"
    }
    case object RequiredPublicKeyMissingForFunctionHeader extends AbiErrorCode {
      override val code: String = "309"
    }
  }
  case class AbiEvent(name: String, inputs: List[AbiParam], id: Option[Option[String]])
  case class AbiFunction(name: String, inputs: List[AbiParam], outputs: List[AbiParam], id: Option[Option[String]])
  case class AbiHandle(value: BigInt) extends AnyVal
  case class AbiParam(name: String, `type`: String, components: Option[List[AbiParam]])
  case class CallSet(function_name: String, header: Option[FunctionHeader], input: Option[Value])
  case class DecodedMessageBody(body_type: MessageBodyType, name: String, value: Option[Value], header: Option[FunctionHeader])
  case class DeploySet(tvc: String, workchain_id: Option[Int], initial_data: Option[Value], initial_pubkey: Option[String])
  /**
   * The ABI function header.
   * Includes several hidden function parameters that contract
   * uses for security, message delivery monitoring and replay protection reasons.
   *
   * The actual set of header fields depends on the contract's ABI.
   * If a contract's ABI does not include some headers, then they are not filled.
   */
  case class FunctionHeader(expire: Option[Long], time: Option[BigInt], pubkey: Option[String])
  object MessageBodyTypeEnum {
    sealed trait MessageBodyType
    /** Message contains the input of the ABI event. */
    case object Event extends MessageBodyType
    /** Message contains the input of the ABI function. */
    case object Input extends MessageBodyType
    /**
     * Message contains the input of the imported ABI function.
     * Occurs when contract sends an internal message to other
     * contract.
     */
    case object InternalOutput extends MessageBodyType
    /** Message contains the output of the ABI function. */
    case object Output extends MessageBodyType
  }
  object MessageSourceADT {
    sealed trait MessageSource
    case class Encoded(message: String, abi: Option[Abi]) extends MessageSource
    case class EncodingParams(value: ParamsOfEncodeMessage) extends MessageSource
  }
  case class ParamsOfAttachSignature(abi: Abi, public_key: String, message: String, signature: String)
  case class ParamsOfAttachSignatureToMessageBody(abi: Abi, public_key: String, message: String, signature: String)
  case class ParamsOfDecodeAccountData(abi: Abi, data: String)
  case class ParamsOfDecodeInitialData(abi: Option[Abi], data: String)
  case class ParamsOfDecodeMessage(abi: Abi, message: String)
  case class ParamsOfDecodeMessageBody(abi: Abi, body: String, is_internal: Boolean)
  case class ParamsOfEncodeAccount(state_init: StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long], boc_cache: Option[BocCacheType])
  case class ParamsOfEncodeInternalMessage(abi: Option[Abi], address: Option[String], src_address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], value: String, bounce: Option[Boolean], enable_ihr: Option[Boolean])
  case class ParamsOfEncodeMessage(abi: Abi, address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], signer: Signer, processing_try_index: Option[Long])
  case class ParamsOfEncodeMessageBody(abi: Abi, call_set: CallSet, is_internal: Boolean, signer: Signer, processing_try_index: Option[Long])
  case class ParamsOfUpdateInitialData(abi: Option[Abi], data: String, initial_data: Option[Value], initial_pubkey: Option[String], boc_cache: Option[BocCacheType])
  case class ResultOfAttachSignature(message: String, message_id: String)
  case class ResultOfAttachSignatureToMessageBody(body: String)
  case class ResultOfDecodeData(data: Value)
  case class ResultOfDecodeInitialData(initial_data: Option[Value], initial_pubkey: String)
  case class ResultOfEncodeAccount(account: String, id: String)
  case class ResultOfEncodeInternalMessage(message: String, address: String, message_id: String)
  case class ResultOfEncodeMessage(message: String, data_to_sign: Option[String], address: String, message_id: String)
  case class ResultOfEncodeMessageBody(body: String, data_to_sign: Option[String])
  case class ResultOfUpdateInitialData(data: String)
  object SignerADT {
    sealed trait Signer
    case class External(public_key: String) extends Signer
    case class Keys(keys: KeyPair) extends Signer
    /**
     * No keys are provided.
     * Creates an unsigned message.
     */
    case object None extends Signer
    case class SigningBox(handle: SigningBoxHandle) extends Signer
  }
  case class StateInitParams(abi: Abi, value: Value)
  object StateInitSourceADT {
    sealed trait StateInitSource
    case class Message(source: MessageSource) extends StateInitSource
    case class StateInit(code: String, data: String, library: Option[String]) extends StateInitSource
    case class Tvc(tvc: String, public_key: Option[String], init_params: Option[StateInitParams]) extends StateInitSource
  }
}
package abi {
  /**
   * Combines `hex`-encoded `signature` with `base64`-encoded `unsigned_message`. Returns signed message encoded in `base64`.
   * @param abi abi
   * @param public_key public_key
   * @param message message
   * @param signature signature
   */
  def attachSignature(abi: Abi, public_key: String, message: String, signature: String): Future[Either[Throwable, ResultOfAttachSignature]]
  /**
   * @param abi abi
   * @param public_key Must be encoded with `hex`.
   * @param message Must be encoded with `base64`.
   * @param signature Must be encoded with `hex`.
   */
  def attachSignatureToMessageBody(abi: Abi, public_key: String, message: String, signature: String): Future[Either[Throwable, ResultOfAttachSignatureToMessageBody]]
  /**
   * Decodes account data using provided data BOC and ABI.
   * Note: this feature requires ABI 2.1 or higher.
   * @param abi abi
   * @param data data
   */
  def decodeAccountData(abi: Abi, data: String): Future[Either[Throwable, ResultOfDecodeData]]
  /**
   * Decodes initial values of a contract's static variables and owner's public key from account initial data This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn't contain this data section any more.
   * @param abi Initial data is decoded if this parameter is provided
   * @param data data
   */
  def decodeInitialData(abi: Option[Abi], data: String): Future[Either[Throwable, ResultOfDecodeInitialData]]
  /**
   * Decodes message body using provided message BOC and ABI.
   * @param abi abi
   * @param message message
   */
  def decodeMessage(abi: Abi, message: String): Future[Either[Throwable, DecodedMessageBody]]
  /**
   * Decodes message body using provided body BOC and ABI.
   * @param abi abi
   * @param body body
   * @param is_internal is_internal
   */
  def decodeMessageBody(abi: Abi, body: String, is_internal: Boolean): Future[Either[Throwable, DecodedMessageBody]]
  /**
   * Creates account state BOC
   * Creates account state provided with one of these sets of data :
   * 1. BOC of code, BOC of data, BOC of library
   * 2. TVC (string in `base64`), keys, init params
   * @param state_init state_init
   * @param balance balance
   * @param last_trans_lt last_trans_lt
   * @param last_paid last_paid
   * @param boc_cache The BOC itself returned if no cache type provided
   */
  def encodeAccount(state_init: StateInitSource, balance: Option[BigInt], last_trans_lt: Option[BigInt], last_paid: Option[Long], boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfEncodeAccount]]
  /**
   * Encodes an internal ABI-compatible message
   * Allows to encode deploy and function call messages.
   *
   * Use cases include messages of any possible type:
   * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
   * of initialization);
   * - deploy without initial function call;
   * - simple function call
   *
   * There is an optional public key can be provided in deploy set in order to substitute one
   * in TVM file.
   *
   * Public key resolving priority:
   * 1. Public key from deploy set.
   * 2. Public key, specified in TVM file.
   * @param abi Can be None if both deploy_set and call_set are None.
   * @param address Must be specified in case of non-deploy message.
   * @param src_address src_address
   * @param deploy_set Must be specified in case of deploy message.
   * @param call_set Must be specified in case of non-deploy message.
   *
   * In case of deploy message it is optional and contains parameters
   * of the functions that will to be called upon deploy transaction.
   * @param value value
   * @param bounce Default is true.
   * @param enable_ihr Default is false.
   */
  def encodeInternalMessage(abi: Option[Abi], address: Option[String], src_address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], value: String, bounce: Option[Boolean], enable_ihr: Option[Boolean]): Future[Either[Throwable, ResultOfEncodeInternalMessage]]
  /**
   * Encodes an ABI-compatible message
   * Allows to encode deploy and function call messages,
   * both signed and unsigned.
   *
   * Use cases include messages of any possible type:
   * - deploy with initial function call (i.e. `constructor` or any other function that is used for some kind
   * of initialization);
   * - deploy without initial function call;
   * - signed/unsigned + data for signing.
   *
   * `Signer` defines how the message should or shouldn't be signed:
   *
   * `Signer::None` creates an unsigned message. This may be needed in case of some public methods,
   * that do not require authorization by pubkey.
   *
   * `Signer::External` takes public key and returns `data_to_sign` for later signing.
   * Use `attach_signature` method with the result signature to get the signed message.
   *
   * `Signer::Keys` creates a signed message with provided key pair.
   *
   * [SOON] `Signer::SigningBox` Allows using a special interface to implement signing
   * without private key disclosure to SDK. For instance, in case of using a cold wallet or HSM,
   * when application calls some API to sign data.
   *
   * There is an optional public key can be provided in deploy set in order to substitute one
   * in TVM file.
   *
   * Public key resolving priority:
   * 1. Public key from deploy set.
   * 2. Public key, specified in TVM file.
   * 3. Public key, provided by signer.
   * @param abi abi
   * @param address Must be specified in case of non-deploy message.
   * @param deploy_set Must be specified in case of deploy message.
   * @param call_set Must be specified in case of non-deploy message.
   *
   * In case of deploy message it is optional and contains parameters
   * of the functions that will to be called upon deploy transaction.
   * @param signer signer
   * @param processing_try_index Used in message processing with retries (if contract's ABI includes "expire" header).
   *
   * Encoder uses the provided try index to calculate message
   * expiration time. The 1st message expiration time is specified in
   * Client config.
   *
   * Expiration timeouts will grow with every retry.
   * Retry grow factor is set in Client config:
   * <.....add config parameter with default value here>
   *
   * Default value is 0.
   */
  def encodeMessage(abi: Abi, address: Option[String], deploy_set: Option[DeploySet], call_set: Option[CallSet], signer: Signer, processing_try_index: Option[Long]): Future[Either[Throwable, ResultOfEncodeMessage]]
  /**
   * Encodes message body according to ABI function call.
   * @param abi abi
   * @param call_set Must be specified in non deploy message.
   *
   * In case of deploy message contains parameters of constructor.
   * @param is_internal is_internal
   * @param signer signer
   * @param processing_try_index Used in message processing with retries.
   *
   * Encoder uses the provided try index to calculate message
   * expiration time.
   *
   * Expiration timeouts will grow with every retry.
   *
   * Default value is 0.
   */
  def encodeMessageBody(abi: Abi, call_set: CallSet, is_internal: Boolean, signer: Signer, processing_try_index: Option[Long]): Future[Either[Throwable, ResultOfEncodeMessageBody]]
  /**
   * Updates initial account data with initial values for the contract's static variables and owner's public key. This operation is applicable only for initial account data (before deploy). If the contract is already deployed, its data doesn't contain this data section any more.
   * @param abi abi
   * @param data data
   * @param initial_data `abi` parameter should be provided to set initial data
   * @param initial_pubkey initial_pubkey
   * @param boc_cache boc_cache
   */
  def updateInitialData(abi: Option[Abi], data: String, initial_data: Option[Value], initial_pubkey: Option[String], boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfUpdateInitialData]]
}
package boc {
  object BocCacheTypeADT {
    sealed trait BocCacheType
    case class Pinned(pin: String) extends BocCacheType
    /**   */
    case object Unpinned extends BocCacheType
  }
  object BocErrorCodeEnum {
    sealed trait BocErrorCode {
      val code: String
    }
    case object BocRefNotFound extends BocErrorCode {
      override val code: String = "206"
    }
    case object InappropriateBlock extends BocErrorCode {
      override val code: String = "203"
    }
    case object InsufficientCacheSize extends BocErrorCode {
      override val code: String = "205"
    }
    case object InvalidBoc extends BocErrorCode {
      override val code: String = "201"
    }
    case object InvalidBocRef extends BocErrorCode {
      override val code: String = "207"
    }
    case object MissingSourceBoc extends BocErrorCode {
      override val code: String = "204"
    }
    case object SerializationError extends BocErrorCode {
      override val code: String = "202"
    }
  }
  object BuilderOpADT {
    /** Cell builder operation. */
    sealed trait BuilderOp
    /** Cell builder operation. */
    case class BitString(value: String) extends BuilderOp
    /** Cell builder operation. */
    case class Cell(builder: List[BuilderOp]) extends BuilderOp
    /** Cell builder operation. */
    case class CellBoc(boc: String) extends BuilderOp
    /** Cell builder operation. */
    case class Integer(size: Long, value: Value) extends BuilderOp
  }
  case class ParamsOfBocCacheGet(boc_ref: String)
  case class ParamsOfBocCacheSet(boc: String, cache_type: BocCacheType)
  case class ParamsOfBocCacheUnpin(pin: String, boc_ref: Option[String])
  case class ParamsOfDecodeTvc(tvc: String, boc_cache: Option[BocCacheType])
  case class ParamsOfEncodeBoc(builder: List[BuilderOp], boc_cache: Option[BocCacheType])
  case class ParamsOfEncodeTvc(code: Option[String], data: Option[String], library: Option[String], tick: Option[Boolean], tock: Option[Boolean], split_depth: Option[Long], boc_cache: Option[BocCacheType])
  case class ParamsOfGetBlockchainConfig(block_boc: String)
  case class ParamsOfGetBocHash(boc: String)
  case class ParamsOfGetCodeFromTvc(tvc: String)
  case class ParamsOfGetCodeSalt(code: String, boc_cache: Option[BocCacheType])
  case class ParamsOfGetCompilerVersion(code: String)
  case class ParamsOfParse(boc: String)
  case class ParamsOfParseShardstate(boc: String, id: String, workchain_id: Int)
  case class ParamsOfSetCodeSalt(code: String, salt: String, boc_cache: Option[BocCacheType])
  case class ResultOfBocCacheGet(boc: Option[String])
  case class ResultOfBocCacheSet(boc_ref: String)
  case class ResultOfDecodeTvc(code: Option[String], data: Option[String], library: Option[String], tick: Option[Boolean], tock: Option[Boolean], split_depth: Option[Long])
  case class ResultOfEncodeBoc(boc: String)
  case class ResultOfEncodeTvc(tvc: String)
  case class ResultOfGetBlockchainConfig(config_boc: String)
  case class ResultOfGetBocHash(hash: String)
  case class ResultOfGetCodeFromTvc(code: String)
  case class ResultOfGetCodeSalt(salt: Option[String])
  case class ResultOfGetCompilerVersion(version: Option[String])
  case class ResultOfParse(parsed: Value)
  case class ResultOfSetCodeSalt(code: String)
}
package boc {
  /**
   * Get BOC from cache
   * @param boc_ref boc_ref
   */
  def cacheGet(boc_ref: String): Future[Either[Throwable, ResultOfBocCacheGet]]
  /**
   * Save BOC into cache
   * @param boc boc
   * @param cache_type cache_type
   */
  def cacheSet(boc: String, cache_type: BocCacheType): Future[Either[Throwable, ResultOfBocCacheSet]]
  /**
   * Unpin BOCs with specified pin.
   * BOCs which don't have another pins will be removed from cache
   * @param pin pin
   * @param boc_ref If it is provided then only referenced BOC is unpinned
   */
  def cacheUnpin(pin: String, boc_ref: Option[String]): Future[Either[Throwable, Unit]]
  /**
   * Decodes tvc into code, data, libraries and special options.
   * @param tvc tvc
   * @param boc_cache boc_cache
   */
  def decodeTvc(tvc: String, boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfDecodeTvc]]
  /**
   * Encodes bag of cells (BOC) with builder operations. This method provides the same functionality as Solidity TvmBuilder. Resulting BOC of this method can be passed into Solidity and C++ contracts as TvmCell type
   * @param builder builder
   * @param boc_cache boc_cache
   */
  def encodeBoc(builder: List[BuilderOp], boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfEncodeBoc]]
  /**
   * Encodes tvc from code, data, libraries ans special options (see input params)
   * @param code code
   * @param data data
   * @param library library
   * @param tick Specifies the contract ability to handle tick transactions
   * @param tock Specifies the contract ability to handle tock transactions
   * @param split_depth split_depth
   * @param boc_cache boc_cache
   */
  def encodeTvc(code: Option[String], data: Option[String], library: Option[String], tick: Option[Boolean], tock: Option[Boolean], split_depth: Option[Long], boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfEncodeTvc]]
  /**
   * Extract blockchain configuration from key block and also from zerostate.
   * @param block_boc block_boc
   */
  def getBlockchainConfig(block_boc: String): Future[Either[Throwable, ResultOfGetBlockchainConfig]]
  /**
   * Calculates BOC root hash
   * @param boc boc
   */
  def getBocHash(boc: String): Future[Either[Throwable, ResultOfGetBocHash]]
  /**
   * Extracts code from TVC contract image
   * @param tvc tvc
   */
  def getCodeFromTvc(tvc: String): Future[Either[Throwable, ResultOfGetCodeFromTvc]]
  /**
   * Returns the contract code's salt if it is present.
   * @param code code
   * @param boc_cache boc_cache
   */
  def getCodeSalt(code: String, boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfGetCodeSalt]]
  /**
   * Returns the compiler version used to compile the code.
   * @param code code
   */
  def getCompilerVersion(code: String): Future[Either[Throwable, ResultOfGetCompilerVersion]]
  /**
   * Parses account boc into a JSON
   * JSON structure is compatible with GraphQL API account object
   * @param boc boc
   */
  def parseAccount(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses block boc into a JSON
   * JSON structure is compatible with GraphQL API block object
   * @param boc boc
   */
  def parseBlock(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses message boc into a JSON
   * JSON structure is compatible with GraphQL API message object
   * @param boc boc
   */
  def parseMessage(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses shardstate boc into a JSON
   * JSON structure is compatible with GraphQL API shardstate object
   * @param boc boc
   * @param id id
   * @param workchain_id workchain_id
   */
  def parseShardstate(boc: String, id: String, workchain_id: Int): Future[Either[Throwable, ResultOfParse]]
  /**
   * Parses transaction boc into a JSON
   * JSON structure is compatible with GraphQL API transaction object
   * @param boc boc
   */
  def parseTransaction(boc: String): Future[Either[Throwable, ResultOfParse]]
  /**
   * Sets new salt to contract code.
   * Returns the new contract code with salt.
   * @param code code
   * @param salt BOC encoded as base64 or BOC handle
   * @param boc_cache boc_cache
   */
  def setCodeSalt(code: String, salt: String, boc_cache: Option[BocCacheType]): Future[Either[Throwable, ResultOfSetCodeSalt]]
}
package processing {
  case class DecodedOutput(out_messages: List[Option[DecodedMessageBody]], output: Option[Value])
  case class ParamsOfProcessMessage(message_encode_params: ParamsOfEncodeMessage, send_events: Boolean)
  case class ParamsOfSendMessage(message: String, abi: Option[Abi], send_events: Boolean)
  case class ParamsOfWaitForTransaction(abi: Option[Abi], message: String, shard_block_id: String, send_events: Boolean, sending_endpoints: Option[List[String]])
  object ProcessingErrorCodeEnum {
    sealed trait ProcessingErrorCode {
      val code: String
    }
    case object BlockNotFound extends ProcessingErrorCode {
      override val code: String = "511"
    }
    case object CanNotBuildMessageCell extends ProcessingErrorCode {
      override val code: String = "503"
    }
    case object CanNotCheckBlockShard extends ProcessingErrorCode {
      override val code: String = "510"
    }
    case object ExternalSignerMustNotBeUsed extends ProcessingErrorCode {
      override val code: String = "513"
    }
    case object FetchBlockFailed extends ProcessingErrorCode {
      override val code: String = "504"
    }
    case object InvalidBlockReceived extends ProcessingErrorCode {
      override val code: String = "509"
    }
    case object InvalidData extends ProcessingErrorCode {
      override val code: String = "512"
    }
    case object InvalidMessageBoc extends ProcessingErrorCode {
      override val code: String = "506"
    }
    case object MessageAlreadyExpired extends ProcessingErrorCode {
      override val code: String = "501"
    }
    case object MessageExpired extends ProcessingErrorCode {
      override val code: String = "507"
    }
    case object MessageHasNotDestinationAddress extends ProcessingErrorCode {
      override val code: String = "502"
    }
    case object SendMessageFailed extends ProcessingErrorCode {
      override val code: String = "505"
    }
    case object TransactionWaitTimeout extends ProcessingErrorCode {
      override val code: String = "508"
    }
  }
  object ProcessingEventADT {
    sealed trait ProcessingEvent
    case class DidSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
    case class FetchFirstBlockFailed(error: ClientError) extends ProcessingEvent
    case class FetchNextBlockFailed(shard_block_id: String, message_id: String, message: String, error: ClientError) extends ProcessingEvent
    case class MessageExpired(message_id: String, message: String, error: ClientError) extends ProcessingEvent
    case class SendFailed(shard_block_id: String, message_id: String, message: String, error: ClientError) extends ProcessingEvent
    /**
     * Notifies the application that the account's current shard block will be fetched from the network. This step is performed before the message sending so that sdk knows starting from which block it will search for the transaction.
     * Fetched block will be used later in waiting phase.
     */
    case object WillFetchFirstBlock extends ProcessingEvent
    case class WillFetchNextBlock(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
    case class WillSend(shard_block_id: String, message_id: String, message: String) extends ProcessingEvent
  }
  case class ResultOfProcessMessage(transaction: Value, out_messages: List[String], decoded: Option[DecodedOutput], fees: TransactionFees)
  case class ResultOfSendMessage(shard_block_id: String, sending_endpoints: List[String])
}
package processing {
  /**
   * Creates message, sends it to the network and monitors its processing.
   * Creates ABI-compatible message,
   * sends it to the network and monitors for the result transaction.
   * Decodes the output messages' bodies.
   *
   * If contract's ABI includes "expire" header, then
   * SDK implements retries in case of unsuccessful message delivery within the expiration
   * timeout: SDK recreates the message, sends it and processes it again.
   *
   * The intermediate events, such as `WillFetchFirstBlock`, `WillSend`, `DidSend`,
   * `WillFetchNextBlock`, etc - are switched on/off by `send_events` flag
   * and logged into the supplied callback function.
   *
   * The retry configuration parameters are defined in the client's `NetworkConfig` and `AbiConfig`.
   *
   * If contract's ABI does not include "expire" header
   * then, if no transaction is found within the network timeout (see config parameter ), exits with error.
   * @param message_encode_params message_encode_params
   * @param send_events send_events
   * @param request request
   */
  def processMessage(message_encode_params: ParamsOfEncodeMessage, send_events: Boolean, request: Request): Future[Either[Throwable, ResultOfProcessMessage]]
  /**
   * Sends message to the network and returns the last generated shard block of the destination account
   * before the message was sent. It will be required later for message processing.
   * @param message message
   * @param abi If this parameter is specified and the message has the
   * `expire` header then expiration time will be checked against
   * the current time to prevent unnecessary sending of already expired message.
   *
   * The `message already expired` error will be returned in this
   * case.
   *
   * Note, that specifying `abi` for ABI compliant contracts is
   * strongly recommended, so that proper processing strategy can be
   * chosen.
   * @param send_events send_events
   * @param callback callback
   */
  def sendMessage(message: String, abi: Option[Abi], send_events: Boolean, callback: Request): Future[Either[Throwable, ResultOfSendMessage]]
  /**
   * Performs monitoring of the network for the result transaction of the external inbound message processing.
   * `send_events` enables intermediate events, such as `WillFetchNextBlock`,
   * `FetchNextBlockFailed` that may be useful for logging of new shard blocks creation
   * during message processing.
   *
   * Note, that presence of the `abi` parameter is critical for ABI
   * compliant contracts. Message processing uses drastically
   * different strategy for processing message for contracts which
   * ABI includes "expire" header.
   *
   * When the ABI header `expire` is present, the processing uses
   * `message expiration` strategy:
   * - The maximum block gen time is set to
   *   `message_expiration_timeout + transaction_wait_timeout`.
   * - When maximum block gen time is reached, the processing will
   *   be finished with `MessageExpired` error.
   *
   * When the ABI header `expire` isn't present or `abi` parameter
   * isn't specified, the processing uses `transaction waiting`
   * strategy:
   * - The maximum block gen time is set to
   *   `now() + transaction_wait_timeout`.
   *
   * - If maximum block gen time is reached and no result transaction is found,
   * the processing will exit with an error.
   * @param abi If it is specified, then the output messages' bodies will be
   * decoded according to this ABI.
   *
   * The `abi_decoded` result field will be filled out.
   * @param message Encoded with `base64`.
   * @param shard_block_id You must provide the same value as the `send_message` has returned.
   * @param send_events send_events
   * @param sending_endpoints Use this field to get more informative errors.
   * Provide the same value as the `send_message` has returned.
   * If the message was not delivered (expired), SDK will log the endpoint URLs, used for its sending.
   * @param callback callback
   */
  def waitForTransaction(abi: Option[Abi], message: String, shard_block_id: String, send_events: Boolean, sending_endpoints: Option[List[String]], callback: Request): Future[Either[Throwable, ResultOfProcessMessage]]
}
package utils {
  object AccountAddressTypeEnum {
    sealed trait AccountAddressType
    case object AccountId extends AccountAddressType
    case object Base64 extends AccountAddressType
    case object Hex extends AccountAddressType
  }
  object AddressStringFormatADT {
    sealed trait AddressStringFormat
    case object AccountId extends AddressStringFormat
    case class Base64(url: Boolean, test: Boolean, bounce: Boolean) extends AddressStringFormat
    case object Hex extends AddressStringFormat
  }
  case class ParamsOfCalcStorageFee(account: String, period: Long)
  case class ParamsOfCompressZstd(uncompressed: String, level: Option[Int])
  case class ParamsOfConvertAddress(address: String, output_format: AddressStringFormat)
  case class ParamsOfDecompressZstd(compressed: String)
  case class ParamsOfGetAddressType(address: String)
  case class ResultOfCalcStorageFee(fee: String)
  case class ResultOfCompressZstd(compressed: String)
  case class ResultOfConvertAddress(address: String)
  case class ResultOfDecompressZstd(decompressed: String)
  case class ResultOfGetAddressType(address_type: AccountAddressType)
}
package utils {
  /**
   * Calculates storage fee for an account over a specified time period
   * @param account account
   * @param period period
   */
  def calcStorageFee(account: String, period: Long): Future[Either[Throwable, ResultOfCalcStorageFee]]
  /**
   * Compresses data using Zstandard algorithm
   * @param uncompressed Must be encoded as base64.
   * @param level level
   */
  def compressZstd(uncompressed: String, level: Option[Int]): Future[Either[Throwable, ResultOfCompressZstd]]
  /**
   * Converts address from any TON format to any TON format
   * @param address address
   * @param output_format output_format
   */
  def convertAddress(address: String, output_format: AddressStringFormat): Future[Either[Throwable, ResultOfConvertAddress]]
  /**
   * Decompresses data using Zstandard algorithm
   * @param compressed Must be encoded as base64.
   */
  def decompressZstd(compressed: String): Future[Either[Throwable, ResultOfDecompressZstd]]
  /**
   * Validates and returns the type of any TON address.
   * Address types are the following
   *
   * `0:919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - standard TON address most
   * commonly used in all cases. Also called as hex address
   * `919db8e740d50bf349df2eea03fa30c385d846b991ff5542e67098ee833fc7f7` - account ID. A part of full
   * address. Identifies account inside particular workchain
   * `EQCRnbjnQNUL80nfLuoD+jDDhdhGuZH/VULmcJjugz/H9wam` - base64 address. Also called "user-friendly".
   * Was used at the beginning of TON. Now it is supported for compatibility
   * @param address address
   */
  def getAddressType(address: String): Future[Either[Throwable, ResultOfGetAddressType]]
}
package tvm {
  object AccountForExecutorADT {
    sealed trait AccountForExecutor
    case class Account(boc: String, unlimited_balance: Option[Boolean]) extends AccountForExecutor
    /** Non-existing account to run a creation internal message. Should be used with `skip_transaction_check = true` if the message has no deploy data since transactions on the uninitialized account are always aborted */
    case object None extends AccountForExecutor
    /** Emulate uninitialized account to run deploy message */
    case object Uninit extends AccountForExecutor
  }
  case class ExecutionOptions(blockchain_config: Option[String], block_time: Option[Long], block_lt: Option[BigInt], transaction_lt: Option[BigInt])
  case class ParamsOfRunExecutor(message: String, account: AccountForExecutor, execution_options: Option[ExecutionOptions], abi: Option[Abi], skip_transaction_check: Option[Boolean], boc_cache: Option[BocCacheType], return_updated_account: Option[Boolean])
  case class ParamsOfRunGet(account: String, function_name: String, input: Option[Value], execution_options: Option[ExecutionOptions], tuple_list_as_array: Option[Boolean])
  case class ParamsOfRunTvm(message: String, account: String, execution_options: Option[ExecutionOptions], abi: Option[Abi], boc_cache: Option[BocCacheType], return_updated_account: Option[Boolean])
  case class ResultOfRunExecutor(transaction: Value, out_messages: List[String], decoded: Option[DecodedOutput], account: String, fees: TransactionFees)
  case class ResultOfRunGet(output: Value)
  case class ResultOfRunTvm(out_messages: List[String], decoded: Option[DecodedOutput], account: String)
  case class TransactionFees(in_msg_fwd_fee: BigInt, storage_fee: BigInt, gas_fee: BigInt, out_msgs_fwd_fee: BigInt, total_account_fees: BigInt, total_output: BigInt)
  object TvmErrorCodeEnum {
    sealed trait TvmErrorCode {
      val code: String
    }
    case object AccountCodeMissing extends TvmErrorCode {
      override val code: String = "406"
    }
    case object AccountFrozenOrDeleted extends TvmErrorCode {
      override val code: String = "408"
    }
    case object AccountMissing extends TvmErrorCode {
      override val code: String = "409"
    }
    case object ActionPhaseFailed extends TvmErrorCode {
      override val code: String = "405"
    }
    case object CanNotReadBlockchainConfig extends TvmErrorCode {
      override val code: String = "402"
    }
    case object CanNotReadTransaction extends TvmErrorCode {
      override val code: String = "401"
    }
    case object ContractExecutionError extends TvmErrorCode {
      override val code: String = "414"
    }
    case object InternalError extends TvmErrorCode {
      override val code: String = "404"
    }
    case object InvalidAccountBoc extends TvmErrorCode {
      override val code: String = "412"
    }
    case object InvalidInputStack extends TvmErrorCode {
      override val code: String = "411"
    }
    case object InvalidMessageType extends TvmErrorCode {
      override val code: String = "413"
    }
    case object LowBalance extends TvmErrorCode {
      override val code: String = "407"
    }
    case object TransactionAborted extends TvmErrorCode {
      override val code: String = "403"
    }
    case object UnknownExecutionError extends TvmErrorCode {
      override val code: String = "410"
    }
  }
}
package tvm {
  /**
   * Emulates all the phases of contract execution locally
   * Performs all the phases of contract execution on Transaction Executor -
   * the same component that is used on Validator Nodes.
   *
   * Can be used for contract debugging, to find out the reason why a message was not delivered successfully.
   * Validators throw away the failed external inbound messages (if they failed bedore `ACCEPT`) in the real network.
   * This is why these messages are impossible to debug in the real network.
   * With the help of run_executor you can do that. In fact, `process_message` function
   * performs local check with `run_executor` if there was no transaction as a result of processing
   * and returns the error, if there is one.
   *
   * Another use case to use `run_executor` is to estimate fees for message execution.
   * Set  `AccountForExecutor::Account.unlimited_balance`
   * to `true` so that emulation will not depend on the actual balance.
   * This may be needed to calculate deploy fees for an account that does not exist yet.
   * JSON with fees is in `fees` field of the result.
   *
   * One more use case - you can produce the sequence of operations,
   * thus emulating the sequential contract calls locally.
   * And so on.
   *
   * Transaction executor requires account BOC (bag of cells) as a parameter.
   * To get the account BOC - use `net.query` method to download it from GraphQL API
   * (field `boc` of `account`) or generate it with `abi.encode_account` method.
   *
   * Also it requires message BOC. To get the message BOC - use `abi.encode_message` or `abi.encode_internal_message`.
   *
   * If you need this emulation to be as precise as possible (for instance - emulate transaction
   * with particular lt in particular block or use particular blockchain config,
   * downloaded from a particular key block - then specify `execution_options` parameter.
   *
   * If you need to see the aborted transaction as a result, not as an error, set `skip_transaction_check` to `true`.
   * @param message Must be encoded as base64.
   * @param account account
   * @param execution_options execution_options
   * @param abi abi
   * @param skip_transaction_check skip_transaction_check
   * @param boc_cache The BOC itself returned if no cache type provided
   * @param return_updated_account Empty string is returned if the flag is `false`
   */
  def runExecutor(message: String, account: AccountForExecutor, execution_options: Option[ExecutionOptions], abi: Option[Abi], skip_transaction_check: Option[Boolean], boc_cache: Option[BocCacheType], return_updated_account: Option[Boolean]): Future[Either[Throwable, ResultOfRunExecutor]]
  /**
   * Executes a get-method of FIFT contract that fulfills the smc-guidelines https://test.ton.org/smc-guidelines.txt
   * and returns the result data from TVM's stack
   * @param account account
   * @param function_name function_name
   * @param input input
   * @param execution_options execution_options
   * @param tuple_list_as_array Default is `false`. Input parameters may use any of lists representations
   * If you receive this error on Web: "Runtime error. Unreachable code should not be executed...",
   * set this flag to true.
   * This may happen, for example, when elector contract contains too many participants
   */
  def runGet(account: String, function_name: String, input: Option[Value], execution_options: Option[ExecutionOptions], tuple_list_as_array: Option[Boolean]): Future[Either[Throwable, ResultOfRunGet]]
  /**
   * Executes get-methods of ABI-compatible contracts
   * Performs only a part of compute phase of transaction execution
   * that is used to run get-methods of ABI-compatible contracts.
   *
   * If you try to run get-methods with `run_executor` you will get an error, because it checks ACCEPT and exits
   * if there is none, which is actually true for get-methods.
   *
   *  To get the account BOC (bag of cells) - use `net.query` method to download it from GraphQL API
   * (field `boc` of `account`) or generate it with `abi.encode_account method`.
   * To get the message BOC - use `abi.encode_message` or prepare it any other way, for instance, with FIFT script.
   *
   * Attention! Updated account state is produces as well, but only
   * `account_state.storage.state.data`  part of the BOC is updated.
   * @param message Must be encoded as base64.
   * @param account Must be encoded as base64.
   * @param execution_options execution_options
   * @param abi abi
   * @param boc_cache The BOC itself returned if no cache type provided
   * @param return_updated_account Empty string is returned if the flag is `false`
   */
  def runTvm(message: String, account: String, execution_options: Option[ExecutionOptions], abi: Option[Abi], boc_cache: Option[BocCacheType], return_updated_account: Option[Boolean]): Future[Either[Throwable, ResultOfRunTvm]]
}
package net {
  object AggregationFnEnum {
    sealed trait AggregationFn
    /** Returns an average value for a field in filtered records */
    case object AVERAGE extends AggregationFn
    /** Returns count of filtered record */
    case object COUNT extends AggregationFn
    /** Returns the maximal value for a field in filtered records */
    case object MAX extends AggregationFn
    /** Returns the minimal value for a field in filtered records */
    case object MIN extends AggregationFn
    /** Returns a sum of values for a field in filtered records */
    case object SUM extends AggregationFn
  }
  case class EndpointsSet(endpoints: List[String])
  case class FieldAggregation(field: String, fn: AggregationFn)
  case class MessageNode(id: String, src_transaction_id: Option[String], dst_transaction_id: Option[String], src: Option[String], dst: Option[String], value: Option[String], bounce: Boolean, decoded_body: Option[DecodedMessageBody])
  object NetErrorCodeEnum {
    sealed trait NetErrorCode {
      val code: String
    }
    case object ClockOutOfSync extends NetErrorCode {
      override val code: String = "606"
    }
    case object GetSubscriptionResultFailed extends NetErrorCode {
      override val code: String = "604"
    }
    case object GraphqlError extends NetErrorCode {
      override val code: String = "608"
    }
    case object GraphqlWebsocketInitError extends NetErrorCode {
      override val code: String = "613"
    }
    case object InvalidServerResponse extends NetErrorCode {
      override val code: String = "605"
    }
    case object NetworkModuleResumed extends NetErrorCode {
      override val code: String = "614"
    }
    case object NetworkModuleSuspended extends NetErrorCode {
      override val code: String = "609"
    }
    case object NoEndpointsProvided extends NetErrorCode {
      override val code: String = "612"
    }
    case object NotSupported extends NetErrorCode {
      override val code: String = "611"
    }
    case object QueryFailed extends NetErrorCode {
      override val code: String = "601"
    }
    case object SubscribeFailed extends NetErrorCode {
      override val code: String = "602"
    }
    case object WaitForFailed extends NetErrorCode {
      override val code: String = "603"
    }
    case object WaitForTimeout extends NetErrorCode {
      override val code: String = "607"
    }
    case object WebsocketDisconnected extends NetErrorCode {
      override val code: String = "610"
    }
  }
  case class OrderBy(path: String, direction: SortDirection)
  case class ParamsOfAggregateCollection(collection: String, filter: Option[Value], fields: Option[List[FieldAggregation]])
  case class ParamsOfBatchQuery(operations: List[ParamsOfQueryOperation])
  case class ParamsOfCreateBlockIterator(start_time: Option[Long], end_time: Option[Long], shard_filter: Option[List[String]], result: Option[String])
  case class ParamsOfCreateTransactionIterator(start_time: Option[Long], end_time: Option[Long], shard_filter: Option[List[String]], accounts_filter: Option[List[String]], result: Option[String], include_transfers: Option[Boolean])
  case class ParamsOfFindLastShardBlock(address: String)
  case class ParamsOfIteratorNext(iterator: Long, limit: Option[Long], return_resume_state: Option[Boolean])
  case class ParamsOfQuery(query: String, variables: Option[Value])
  case class ParamsOfQueryCollection(collection: String, filter: Option[Value], result: String, order: Option[List[OrderBy]], limit: Option[Long])
  case class ParamsOfQueryCounterparties(account: String, result: String, first: Option[Long], after: Option[String])
  object ParamsOfQueryOperationADT {
    sealed trait ParamsOfQueryOperation
    case class AggregateCollection(value: ParamsOfAggregateCollection) extends ParamsOfQueryOperation
    case class QueryCollection(value: ParamsOfQueryCollection) extends ParamsOfQueryOperation
    case class QueryCounterparties(value: ParamsOfQueryCounterparties) extends ParamsOfQueryOperation
    case class WaitForCollection(value: ParamsOfWaitForCollection) extends ParamsOfQueryOperation
  }
  case class ParamsOfQueryTransactionTree(in_msg: String, abi_registry: Option[List[Abi]], timeout: Option[Long])
  case class ParamsOfResumeBlockIterator(resume_state: Value)
  case class ParamsOfResumeTransactionIterator(resume_state: Value, accounts_filter: Option[List[String]])
  case class ParamsOfSubscribeCollection(collection: String, filter: Option[Value], result: String)
  case class ParamsOfWaitForCollection(collection: String, filter: Option[Value], result: String, timeout: Option[Long])
  case class RegisteredIterator(handle: Long)
  case class ResultOfAggregateCollection(values: Value)
  case class ResultOfBatchQuery(results: List[Value])
  case class ResultOfFindLastShardBlock(block_id: String)
  case class ResultOfGetEndpoints(query: String, endpoints: List[String])
  case class ResultOfIteratorNext(items: List[Value], has_more: Boolean, resume_state: Option[Value])
  case class ResultOfQuery(result: Value)
  case class ResultOfQueryCollection(result: List[Value])
  case class ResultOfQueryTransactionTree(messages: List[MessageNode], transactions: List[TransactionNode])
  case class ResultOfSubscribeCollection(handle: Long)
  case class ResultOfWaitForCollection(result: Value)
  object SortDirectionEnum {
    sealed trait SortDirection
    case object ASC extends SortDirection
    case object DESC extends SortDirection
  }
  case class TransactionNode(id: String, in_msg: String, out_msgs: List[String], account_addr: String, total_fees: String, aborted: Boolean, exit_code: Option[Long])
}
package net {
  /**
   * Aggregates collection data.
   * Aggregates values from the specified `fields` for records
   * that satisfies the `filter` conditions,
   * @param collection collection
   * @param filter filter
   * @param fields fields
   */
  def aggregateCollection(collection: String, filter: Option[Value], fields: Option[List[FieldAggregation]]): Future[Either[Throwable, ResultOfAggregateCollection]]
  /**
   * Performs multiple queries per single fetch.
   * @param operations operations
   */
  def batchQuery(operations: List[ParamsOfQueryOperation]): Future[Either[Throwable, ResultOfBatchQuery]]
  /**
   * Creates block iterator.
   * Block iterator uses robust iteration methods that guaranties that every
   * block in the specified range isn't missed or iterated twice.
   *
   * Iterated range can be reduced with some filters:
   * - `start_time` – the bottom time range. Only blocks with `gen_utime`
   * more or equal to this value is iterated. If this parameter is omitted then there is
   * no bottom time edge, so all blocks since zero state is iterated.
   * - `end_time` – the upper time range. Only blocks with `gen_utime`
   * less then this value is iterated. If this parameter is omitted then there is
   * no upper time edge, so iterator never finishes.
   * - `shard_filter` – workchains and shard prefixes that reduce the set of interesting
   * blocks. Block conforms to the shard filter if it belongs to the filter workchain
   * and the first bits of block's `shard` fields matches to the shard prefix.
   * Only blocks with suitable shard are iterated.
   *
   * Items iterated is a JSON objects with block data. The minimal set of returned
   * fields is:
   * ```text
   * id
   * gen_utime
   * workchain_id
   * shard
   * after_split
   * after_merge
   * prev_ref {
   *     root_hash
   * }
   * prev_alt_ref {
   *     root_hash
   * }
   * ```
   * Application can request additional fields in the `result` parameter.
   *
   * Application should call the `remove_iterator` when iterator is no longer required.
   * @param start_time If the application specifies this parameter then the iteration
   * includes blocks with `gen_utime` >= `start_time`.
   * Otherwise the iteration starts from zero state.
   *
   * Must be specified in seconds.
   * @param end_time If the application specifies this parameter then the iteration
   * includes blocks with `gen_utime` < `end_time`.
   * Otherwise the iteration never stops.
   *
   * Must be specified in seconds.
   * @param shard_filter If the application specifies this parameter and it is not the empty array
   * then the iteration will include items related to accounts that belongs to
   * the specified shard prefixes.
   * Shard prefix must be represented as a string "workchain:prefix".
   * Where `workchain` is a signed integer and the `prefix` if a hexadecimal
   * representation if the 64-bit unsigned integer with tagged shard prefix.
   * For example: "0:3800000000000000".
   * @param result List of the fields that must be returned for iterated items.
   * This field is the same as the `result` parameter of
   * the `query_collection` function.
   * Note that iterated items can contains additional fields that are
   * not requested in the `result`.
   */
  def createBlockIterator(start_time: Option[Long], end_time: Option[Long], shard_filter: Option[List[String]], result: Option[String]): Future[Either[Throwable, RegisteredIterator]]
  /**
   * Creates transaction iterator.
   * Transaction iterator uses robust iteration methods that guaranty that every
   * transaction in the specified range isn't missed or iterated twice.
   *
   * Iterated range can be reduced with some filters:
   * - `start_time` – the bottom time range. Only transactions with `now`
   * more or equal to this value are iterated. If this parameter is omitted then there is
   * no bottom time edge, so all the transactions since zero state are iterated.
   * - `end_time` – the upper time range. Only transactions with `now`
   * less then this value are iterated. If this parameter is omitted then there is
   * no upper time edge, so iterator never finishes.
   * - `shard_filter` – workchains and shard prefixes that reduce the set of interesting
   * accounts. Account address conforms to the shard filter if
   * it belongs to the filter workchain and the first bits of address match to
   * the shard prefix. Only transactions with suitable account addresses are iterated.
   * - `accounts_filter` – set of account addresses whose transactions must be iterated.
   * Note that accounts filter can conflict with shard filter so application must combine
   * these filters carefully.
   *
   * Iterated item is a JSON objects with transaction data. The minimal set of returned
   * fields is:
   * ```text
   * id
   * account_addr
   * now
   * balance_delta(format:DEC)
   * bounce { bounce_type }
   * in_message {
   *     id
   *     value(format:DEC)
   *     msg_type
   *     src
   * }
   * out_messages {
   *     id
   *     value(format:DEC)
   *     msg_type
   *     dst
   * }
   * ```
   * Application can request an additional fields in the `result` parameter.
   *
   * Another parameter that affects on the returned fields is the `include_transfers`.
   * When this parameter is `true` the iterator computes and adds `transfer` field containing
   * list of the useful `TransactionTransfer` objects.
   * Each transfer is calculated from the particular message related to the transaction
   * and has the following structure:
   * - message – source message identifier.
   * - isBounced – indicates that the transaction is bounced, which means the value will be returned back to the sender.
   * - isDeposit – indicates that this transfer is the deposit (true) or withdraw (false).
   * - counterparty – account address of the transfer source or destination depending on `isDeposit`.
   * - value – amount of nano tokens transferred. The value is represented as a decimal string
   * because the actual value can be more precise than the JSON number can represent. Application
   * must use this string carefully – conversion to number can follow to loose of precision.
   *
   * Application should call the `remove_iterator` when iterator is no longer required.
   * @param start_time If the application specifies this parameter then the iteration
   * includes blocks with `gen_utime` >= `start_time`.
   * Otherwise the iteration starts from zero state.
   *
   * Must be specified in seconds.
   * @param end_time If the application specifies this parameter then the iteration
   * includes blocks with `gen_utime` < `end_time`.
   * Otherwise the iteration never stops.
   *
   * Must be specified in seconds.
   * @param shard_filter If the application specifies this parameter and it is not an empty array
   * then the iteration will include items related to accounts that belongs to
   * the specified shard prefixes.
   * Shard prefix must be represented as a string "workchain:prefix".
   * Where `workchain` is a signed integer and the `prefix` if a hexadecimal
   * representation if the 64-bit unsigned integer with tagged shard prefix.
   * For example: "0:3800000000000000".
   * Account address conforms to the shard filter if
   * it belongs to the filter workchain and the first bits of address match to
   * the shard prefix. Only transactions with suitable account addresses are iterated.
   * @param accounts_filter Application can specify the list of accounts for which
   * it wants to iterate transactions.
   *
   * If this parameter is missing or an empty list then the library iterates
   * transactions for all accounts that pass the shard filter.
   *
   * Note that the library doesn't detect conflicts between the account filter and the shard filter
   * if both are specified.
   * So it is an application responsibility to specify the correct filter combination.
   * @param result List of the fields that must be returned for iterated items.
   * This field is the same as the `result` parameter of
   * the `query_collection` function.
   * Note that iterated items can contain additional fields that are
   * not requested in the `result`.
   * @param include_transfers If this parameter is `true` then each transaction contains field
   * `transfers` with list of transfer. See more about this structure in function description.
   */
  def createTransactionIterator(start_time: Option[Long], end_time: Option[Long], shard_filter: Option[List[String]], accounts_filter: Option[List[String]], result: Option[String], include_transfers: Option[Boolean]): Future[Either[Throwable, RegisteredIterator]]
  /** Requests the list of alternative endpoints from server */
  def fetchEndpoints(): Future[Either[Throwable, EndpointsSet]]
  /**
   * Returns ID of the last block in a specified account shard
   * @param address address
   */
  def findLastShardBlock(address: String): Future[Either[Throwable, ResultOfFindLastShardBlock]]
  /** Requests the list of alternative endpoints from server */
  def getEndpoints(): Future[Either[Throwable, ResultOfGetEndpoints]]
  /**
   * Returns next available items.
   * In addition to available items this function returns the `has_more` flag
   * indicating that the iterator isn't reach the end of the iterated range yet.
   *
   * This function can return the empty list of available items but
   * indicates that there are more items is available.
   * This situation appears when the iterator doesn't reach iterated range
   * but database doesn't contains available items yet.
   *
   * If application requests resume state in `return_resume_state` parameter
   * then this function returns `resume_state` that can be used later to
   * resume the iteration from the position after returned items.
   *
   * The structure of the items returned depends on the iterator used.
   * See the description to the appropriated iterator creation function.
   * @param iterator iterator
   * @param limit If value is missing or is less than 1 the library uses 1.
   * @param return_resume_state return_resume_state
   */
  def iteratorNext(iterator: Long, limit: Option[Long], return_resume_state: Option[Boolean]): Future[Either[Throwable, ResultOfIteratorNext]]
  /**
   * Performs DAppServer GraphQL query.
   * @param query query
   * @param variables Must be a map with named values that can be used in query.
   */
  def query(query: String, variables: Option[Value]): Future[Either[Throwable, ResultOfQuery]]
  /**
   * Queries collection data
   * Queries data that satisfies the `filter` conditions,
   * limits the number of returned records and orders them.
   * The projection fields are limited to `result` fields
   * @param collection collection
   * @param filter filter
   * @param result result
   * @param order order
   * @param limit limit
   */
  def queryCollection(collection: String, filter: Option[Value], result: String, order: Option[List[OrderBy]], limit: Option[Long]): Future[Either[Throwable, ResultOfQueryCollection]]
  /**
   * Allows to query and paginate through the list of accounts that the specified account has interacted with, sorted by the time of the last internal message between accounts
   * *Attention* this query retrieves data from 'Counterparties' service which is not supported in
   * the opensource version of DApp Server (and will not be supported) as well as in TON OS SE (will be supported in SE in future),
   * but is always accessible via [TON OS Devnet/Mainnet Clouds](https://docs.ton.dev/86757ecb2/p/85c869-networks)
   * @param account account
   * @param result result
   * @param first first
   * @param after after
   */
  def queryCounterparties(account: String, result: String, first: Option[Long], after: Option[String]): Future[Either[Throwable, ResultOfQueryCollection]]
  /**
   * Returns a tree of transactions triggered by a specific message.
   * Performs recursive retrieval of a transactions tree produced by a specific message:
   * in_msg -> dst_transaction -> out_messages -> dst_transaction -> ...
   * If the chain of transactions execution is in progress while the function is running,
   * it will wait for the next transactions to appear until the full tree or more than 50 transactions
   * are received.
   *
   * All the retrieved messages and transactions are included
   * into `result.messages` and `result.transactions` respectively.
   *
   * Function reads transactions layer by layer, by pages of 20 transactions.
   *
   * The retrieval prosess goes like this:
   * Let's assume we have an infinite chain of transactions and each transaction generates 5 messages.
   * 1. Retrieve 1st message (input parameter) and corresponding transaction - put it into result.
   * It is the first level of the tree of transactions - its root.
   * Retrieve 5 out message ids from the transaction for next steps.
   * 2. Retrieve 5 messages and corresponding transactions on the 2nd layer. Put them into result.
   * Retrieve 5*5 out message ids from these transactions for next steps
   * 3. Retrieve 20 (size of the page) messages and transactions (3rd layer) and 20*5=100 message ids (4th layer).
   * 4. Retrieve the last 5 messages and 5 transactions on the 3rd layer + 15 messages and transactions (of 100) from the 4th layer
   * + 25 message ids of the 4th layer + 75 message ids of the 5th layer.
   * 5. Retrieve 20 more messages and 20 more transactions of the 4th layer + 100 more message ids of the 5th layer.
   * 6. Now we have 1+5+20+20+20 = 66 transactions, which is more than 50. Function exits with the tree of
   * 1m->1t->5m->5t->25m->25t->35m->35t. If we see any message ids in the last transactions out_msgs, which don't have
   * corresponding messages in the function result, it means that the full tree was not received and we need to continue iteration.
   *
   * To summarize, it is guaranteed that each message in `result.messages` has the corresponding transaction
   * in the `result.transactions`.
   * But there is no guarantee that all messages from transactions `out_msgs` are
   * presented in `result.messages`.
   * So the application has to continue retrieval for missing messages if it requires.
   * @param in_msg in_msg
   * @param abi_registry abi_registry
   * @param timeout If some of the following messages and transactions are missing yet
   * The maximum waiting time is regulated by this option.
   *
   * Default value is 60000 (1 min).
   */
  def queryTransactionTree(in_msg: String, abi_registry: Option[List[Abi]], timeout: Option[Long]): Future[Either[Throwable, ResultOfQueryTransactionTree]]
  /**
   * Removes an iterator
   * Frees all resources allocated in library to serve iterator.
   *
   * Application always should call the `remove_iterator` when iterator
   * is no longer required.
   * @param handle Must be removed using `remove_iterator`
   * when it is no more needed for the application.
   */
  def removeIterator(handle: Long): Future[Either[Throwable, Unit]]
  /** Resumes network module to enable network activity */
  def resume(): Future[Either[Throwable, Unit]]
  /**
   * Resumes block iterator.
   * The iterator stays exactly at the same position where the `resume_state` was catched.
   *
   * Application should call the `remove_iterator` when iterator is no longer required.
   * @param resume_state Same as value returned from `iterator_next`.
   */
  def resumeBlockIterator(resume_state: Value): Future[Either[Throwable, RegisteredIterator]]
  /**
   * Resumes transaction iterator.
   * The iterator stays exactly at the same position where the `resume_state` was caught.
   * Note that `resume_state` doesn't store the account filter. If the application requires
   * to use the same account filter as it was when the iterator was created then the application
   * must pass the account filter again in `accounts_filter` parameter.
   *
   * Application should call the `remove_iterator` when iterator is no longer required.
   * @param resume_state Same as value returned from `iterator_next`.
   * @param accounts_filter Application can specify the list of accounts for which
   * it wants to iterate transactions.
   *
   * If this parameter is missing or an empty list then the library iterates
   * transactions for all accounts that passes the shard filter.
   *
   * Note that the library doesn't detect conflicts between the account filter and the shard filter
   * if both are specified.
   * So it is the application's responsibility to specify the correct filter combination.
   */
  def resumeTransactionIterator(resume_state: Value, accounts_filter: Option[List[String]]): Future[Either[Throwable, RegisteredIterator]]
  /**
   * Sets the list of endpoints to use on reinit
   * @param endpoints endpoints
   */
  def setEndpoints(endpoints: List[String]): Future[Either[Throwable, Unit]]
  /**
   * Creates a subscription
   * Triggers for each insert/update of data that satisfies
   * the `filter` conditions.
   * The projection fields are limited to `result` fields.
   *
   * The subscription is a persistent communication channel between
   * client and Free TON Network.
   * All changes in the blockchain will be reflected in realtime.
   * Changes means inserts and updates of the blockchain entities.
   *
   * ### Important Notes on Subscriptions
   *
   * Unfortunately sometimes the connection with the network brakes down.
   * In this situation the library attempts to reconnect to the network.
   * This reconnection sequence can take significant time.
   * All of this time the client is disconnected from the network.
   *
   * Bad news is that all blockchain changes that happened while
   * the client was disconnected are lost.
   *
   * Good news is that the client report errors to the callback when
   * it loses and resumes connection.
   *
   * So, if the lost changes are important to the application then
   * the application must handle these error reports.
   *
   * Library reports errors with `responseType` == 101
   * and the error object passed via `params`.
   *
   * When the library has successfully reconnected
   * the application receives callback with
   * `responseType` == 101 and `params.code` == 614 (NetworkModuleResumed).
   *
   * Application can use several ways to handle this situation:
   * - If application monitors changes for the single blockchain
   * object (for example specific account):  application
   * can perform a query for this object and handle actual data as a
   * regular data from the subscription.
   * - If application monitors sequence of some blockchain objects
   * (for example transactions of the specific account): application must
   * refresh all cached (or visible to user) lists where this sequences presents.
   * @param collection collection
   * @param filter filter
   * @param result result
   * @param callback callback
   */
  def subscribeCollection(collection: String, filter: Option[Value], result: String, callback: Request): Future[Either[Throwable, ResultOfSubscribeCollection]]
  /** Suspends network module to stop any network activity */
  def suspend(): Future[Either[Throwable, Unit]]
  /**
   * Cancels a subscription specified by its handle.
   * @param handle Must be closed with `unsubscribe`
   */
  def unsubscribe(handle: Long): Future[Either[Throwable, Unit]]
  /**
   * Returns an object that fulfills the conditions or waits for its appearance
   * Triggers only once.
   * If object that satisfies the `filter` conditions
   * already exists - returns it immediately.
   * If not - waits for insert/update of data within the specified `timeout`,
   * and returns it.
   * The projection fields are limited to `result` fields
   * @param collection collection
   * @param filter filter
   * @param result result
   * @param timeout timeout
   */
  def waitForCollection(collection: String, filter: Option[Value], result: String, timeout: Option[Long]): Future[Either[Throwable, ResultOfWaitForCollection]]
}
package debot {
  /** [UNSTABLE](UNSTABLE.md) Describes a debot action in a Debot Context. */
  case class DebotAction(description: String, name: String, action_type: Long, to: Long, attributes: String, misc: String)
  object DebotActivityADT {
    /** [UNSTABLE](UNSTABLE.md) Describes the operation that the DeBot wants to perform. */
    sealed trait DebotActivity
    /** [UNSTABLE](UNSTABLE.md) Describes the operation that the DeBot wants to perform. */
    case class Transaction(msg: String, dst: String, out: List[Spending], fee: BigInt, setcode: Boolean, signkey: String, signing_box_handle: Long) extends DebotActivity
  }
  object DebotErrorCodeEnum {
    sealed trait DebotErrorCode {
      val code: String
    }
    case object DebotBrowserCallbackFailed extends DebotErrorCode {
      override val code: String = "811"
    }
    case object DebotExecutionFailed extends DebotErrorCode {
      override val code: String = "803"
    }
    case object DebotExternalCallFailed extends DebotErrorCode {
      override val code: String = "810"
    }
    case object DebotFetchFailed extends DebotErrorCode {
      override val code: String = "802"
    }
    case object DebotGetMethodFailed extends DebotErrorCode {
      override val code: String = "808"
    }
    case object DebotInvalidAbi extends DebotErrorCode {
      override val code: String = "807"
    }
    case object DebotInvalidFunctionId extends DebotErrorCode {
      override val code: String = "806"
    }
    case object DebotInvalidHandle extends DebotErrorCode {
      override val code: String = "804"
    }
    case object DebotInvalidJsonParams extends DebotErrorCode {
      override val code: String = "805"
    }
    case object DebotInvalidMsg extends DebotErrorCode {
      override val code: String = "809"
    }
    case object DebotOperationRejected extends DebotErrorCode {
      override val code: String = "812"
    }
    case object DebotStartFailed extends DebotErrorCode {
      override val code: String = "801"
    }
  }
  /** [UNSTABLE](UNSTABLE.md) Handle of registered in SDK debot */
  case class DebotHandle(value: BigInt) extends AnyVal
  /** [UNSTABLE](UNSTABLE.md) Describes DeBot metadata. */
  case class DebotInfo(name: Option[String], version: Option[String], publisher: Option[String], caption: Option[String], author: Option[String], support: Option[String], hello: Option[String], language: Option[String], dabi: Option[String], icon: Option[String], interfaces: List[String])
  object ParamsOfAppDebotBrowserADT {
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    sealed trait ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Approve(activity: DebotActivity) extends ParamsOfAppDebotBrowser
    /**
     * Get signing box to sign data.
     * Signing box returned is owned and disposed by debot engine
     */
    case object GetSigningBox extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Input(prompt: String) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class InvokeDebot(debot_addr: String, action: DebotAction) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Log(msg: String) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Send(message: String) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class ShowAction(action: DebotAction) extends ParamsOfAppDebotBrowser
    /**
     * [UNSTABLE](UNSTABLE.md) Debot Browser callbacks
     * Called by debot engine to communicate with debot browser.
     */
    case class Switch(context_id: Long) extends ParamsOfAppDebotBrowser
    /** Notify browser that all context actions are shown. */
    case object SwitchCompleted extends ParamsOfAppDebotBrowser
  }
  /** [UNSTABLE](UNSTABLE.md) Parameters for executing debot action. */
  case class ParamsOfExecute(debot_handle: DebotHandle, action: DebotAction)
  /** [UNSTABLE](UNSTABLE.md) Parameters to fetch DeBot metadata. */
  case class ParamsOfFetch(address: String)
  /** [UNSTABLE](UNSTABLE.md) Parameters to init DeBot. */
  case class ParamsOfInit(address: String)
  /** [UNSTABLE](UNSTABLE.md) */
  case class ParamsOfRemove(debot_handle: DebotHandle)
  /** [UNSTABLE](UNSTABLE.md) Parameters of `send` function. */
  case class ParamsOfSend(debot_handle: DebotHandle, message: String)
  /** [UNSTABLE](UNSTABLE.md) Parameters to start DeBot. DeBot must be already initialized with init() function. */
  case class ParamsOfStart(debot_handle: DebotHandle)
  /** [UNSTABLE](UNSTABLE.md) Structure for storing debot handle returned from `init` function. */
  case class RegisteredDebot(debot_handle: DebotHandle, debot_abi: String, info: DebotInfo)
  object ResultOfAppDebotBrowserADT {
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    sealed trait ResultOfAppDebotBrowser
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    case class Approve(approved: Boolean) extends ResultOfAppDebotBrowser
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    case class GetSigningBox(signing_box: SigningBoxHandle) extends ResultOfAppDebotBrowser
    /** [UNSTABLE](UNSTABLE.md) Returning values from Debot Browser callbacks. */
    case class Input(value: String) extends ResultOfAppDebotBrowser
    /** Result of debot invoking. */
    case object InvokeDebot extends ResultOfAppDebotBrowser
  }
  /** [UNSTABLE](UNSTABLE.md) */
  case class ResultOfFetch(info: DebotInfo)
  /** [UNSTABLE](UNSTABLE.md) Describes how much funds will be debited from the target  contract balance as a result of the transaction. */
  case class Spending(amount: BigInt, dst: String)
}
package debot {
  /**
   * [UNSTABLE](UNSTABLE.md) Executes debot action.
   * Calls debot engine referenced by debot handle to execute input action.
   * Calls Debot Browser Callbacks if needed.
   *
   * # Remarks
   * Chain of actions can be executed if input action generates a list of subactions.
   * @param debot_handle debot_handle
   * @param action action
   */
  def execute(debot_handle: DebotHandle, action: DebotAction): Future[Either[Throwable, Unit]]
  /**
   * [UNSTABLE](UNSTABLE.md) Fetches DeBot metadata from blockchain.
   * Downloads DeBot from blockchain and creates and fetches its metadata.
   * @param address address
   */
  def fetch(address: String): Future[Either[Throwable, ResultOfFetch]]
  /**
   * [UNSTABLE](UNSTABLE.md) Creates and instance of DeBot.
   * Downloads debot smart contract (code and data) from blockchain and creates
   * an instance of Debot Engine for it.
   *
   * # Remarks
   * It does not switch debot to context 0. Browser Callbacks are not called.
   * @param address address
   * @param app_object app_object
   */
  def init(address: String, app_object: ParamsOfAppDebotBrowser => ResultOfAppDebotBrowser): Future[Either[Throwable, RegisteredDebot]]
  /**
   * [UNSTABLE](UNSTABLE.md) Destroys debot handle.
   * Removes handle from Client Context and drops debot engine referenced by that handle.
   * @param debot_handle debot_handle
   */
  def remove(debot_handle: DebotHandle): Future[Either[Throwable, Unit]]
  /**
   * [UNSTABLE](UNSTABLE.md) Sends message to Debot.
   * Used by Debot Browser to send response on Dinterface call or from other Debots.
   * @param debot_handle debot_handle
   * @param message message
   */
  def send(debot_handle: DebotHandle, message: String): Future[Either[Throwable, Unit]]
  /**
   * [UNSTABLE](UNSTABLE.md) Starts the DeBot.
   * Downloads debot smart contract from blockchain and switches it to
   * context zero.
   *
   * This function must be used by Debot Browser to start a dialog with debot.
   * While the function is executing, several Browser Callbacks can be called,
   * since the debot tries to display all actions from the context 0 to the user.
   *
   * When the debot starts SDK registers `BrowserCallbacks` AppObject.
   * Therefore when `debote.remove` is called the debot is being deleted and the callback is called
   * with `finish`=`true` which indicates that it will never be used again.
   * @param debot_handle debot_handle
   */
  def start(debot_handle: DebotHandle): Future[Either[Throwable, Unit]]
}